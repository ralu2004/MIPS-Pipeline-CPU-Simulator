\documentclass[a4paper,12pt]{report}

\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage[margin=2cm]{geometry}
\usepackage{listings}
\usepackage{color}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{tabularx}
\usepackage{rotating}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{float}
\usepackage[backend=biber, style=numeric, sorting=ynt]{biblatex}
\usepackage{colortbl}
\definecolor{headerblue}{RGB}{79,129,189}
\usepackage{tikz}
\usepackage{pdflscape}
\usepackage{comment}
\usetikzlibrary{shapes, arrows, positioning}
%\usepackage{verbatim}
%\usepackage{mdframed}
%\usepackage{algorithmic}
%\usepackage[linesnumbered,ruled,vlined]{algorithm2e}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=black,
    citecolor=black,
    urlcolor=black,
    pdfborder={0 0 0} 
}

\bibliography{citations}

\lstdefinestyle{lstcustom}{
backgroundcolor=\color{backcolour},
commentstyle=\color{codegreen},
keywordstyle=\color{magenta},
numberstyle=\tiny\color{codegray},
stringstyle=\color{codepurple},
basicstyle=\ttfamily\footnotesize,
breakatwhitespace=false,
breaklines=true,
captionpos=b,
keepspaces=true,
numbers=left,
numbersep=5pt,
showspaces=false,
showstringspaces=false,
showtabs=false,
tabsize=2
}

\lstdefinestyle{javaStyle}{
  language=Java,
  basicstyle=\ttfamily\small,
  keywordstyle=\color{blue}\bfseries,
  commentstyle=\color{green!50!black}\itshape,
  stringstyle=\color{orange},
  numbers=left,
  numberstyle=\tiny\color{gray},
  stepnumber=1,
  numbersep=5pt,
  showstringspaces=false,
  tabsize=2,
  breaklines=true,
  frame=single
}

\lstset{style=lstcustom}
\setlength{\parindent}{0pt}

\begin{document}

\vspace{-5cm}
\begin{center}
    Department of Computer Science\\
    Technical University of Cluj-Napoca\\
    \includegraphics[width=10cm]{fig/footer}
    \end{center}
    \vspace{1cm}
    \begin{center}
    \begin{Large}
     \textbf{CPU Simulator}\\
    \end{Large}
    \textit{MIPS Pipeline Architecture}\\
    \vspace{3cm}
    Name:\ Raluca-Mihaela Adam\\
    Group:\ 30422\\
    Email:\ adam.ra.raluca@student.utcluj.ro\\
    \vspace{12cm}
    Teaching Assistant: Dragos Lazea\\
    \vspace{1cm}
    \includegraphics[width=10cm]{fig/footer}
\end{center}

\tableofcontents

\chapter{Introduction}\label{ch:arch}

\section{Context}
This project aims to develop an educational CPU simulation software that mimics the 5-stage MIPS (Microprocessor without Interlocked Pipeline Stages) pipeline based on the 32-bit MIPS Instruction Set Architecture (ISA).

The simulator will visualize the flow of instruction through the MIPS pipeline, detect and display hazards, and help users understand the dynamics of parallel execution inside a CPU through a graphical user interface.

\section{Problem and Motivation}

In traditional computer architecture courses, students often struggle to understand the functioning of the CPU pipeline and the types of hazards that arise during instruction execution. Existing tools, such as MARS and SPIM simulators, allow users to run MIPS assembly programs but do not provide an intuitive visualization of how instructions propagate through the pipeline.

This project addresses this educational gap by providing a visual simulation software that demonstrates how instructions overlap inside a pipeline, how hazards occur, and how forwarding or stalling mechanisms resolve them in an interactive and easy-to-follow manner.

\section{Objectives and Proposed Solution}

The proposed application will consist of:
\begin{itemize}
    \item An execution engine that simulates the MIPS instruction flow and pipeline stages.
    \item An intuitive graphical user interface for interactive visualization that allows users to either input custom MIPS assembly code or select predefined programs.
    \item An assembler component that converts assembly language instructions into binary machine code for execution.
    \item The possibility to simulate 21 MIPS instructions (R, I, and J types).
    \item Real-time visualization of the 5 pipeline stages (IF, ID, EX, MEM, WB).
    \item Display of registers, memory contents, ALU operations, and control flags.
\end{itemize}

\section{Project Timeline and Plan}

The development of the MIPS 32 Simulator will follow a structured timeline, as presented below:

\begin{itemize}
    \item \textbf{Meeting 2:}  
    Documentation phase — prepare the project introduction, bibliographic research, bibliography, and project plan. Establish the main objectives and overall development strategy.
    
    \item \textbf{Meeting 3:}  
    Analysis and \textbf{Design Phase 1} — describe the system architecture, main modules, and component interactions. Provide an initial view of the implementation.
    
    \item \textbf{Meeting 4:}  
    Updated design and \textbf{back-end implementation} — refine the architecture based on feedback and corrections. Begin coding the back-end, defining class structures, storage mechanisms, and pipeline simulation logic.
    
    \item \textbf{Meeting 5:}  
    Finalize the back-end implementation. Begin developing the \textbf{front-end} to visualize the pipeline stages and display simulation data in real time.
    
    \item \textbf{Meeting 6:}  
    \textbf{Testing and validation} — verify functionality through unit and integration tests.
    
    \item \textbf{Meeting 7:}  
    \textbf{Final demo and presentation} — deliver the complete simulator, full documentation, and the final presentation showcasing the system’s capabilities.
\end{itemize}


\chapter{Bibliographic Research}\label{ch:arch}
\section{Importance of CPU Pipelining}
The performance of a processor depends on factors such as clock speed, critical path length, and cycles per instruction (CPI). A single-cycle CPU executes one instruction per clock cycle, making the design simple but inefficient because not all instructions take the same amount of time. Pipelining addresses this limitation by allowing multiple instructions to be processed simultaneously at different stages. The pipeline architecture is designed for throughput, increasing CPU performance, but introduces hazards - structural, data, and control hazards - that must be detected and resolved for correctness.

\section{MIPS Architecture and Pipelining}
The MIPS Architecture is a reduced instruction set computer (RISC) design. Its pipeline implementation consists of 5 execution stages: Instruction Fetch, Instruction Decode, Execute, Memory, and Write Back, which enable the parallel processing of multiple instructions. 

In a software simulator, true parallel execution is not possible; however, an event-based software architecture can create the illusion of concurrency while preserving accuracy in time and hazard detection.

\section{Existing Tools}
Several existing MIPS simulators are available:
\begin{itemize}
    \item \textbf{MARS} \cite{mars} — A Java-based MIPS simulator commonly used in academia. It supports assembly code execution, but is limited by poor visualisation of the pipeline.
    \item \textbf{SPIM} \cite{spim} — One of the earliest MIPS simulators. It is focused mainly on instruction correctness rather than pipeline-level execution.
\end{itemize}

In \cite{cornell}, the authors present a comprehensive theoretical explanation of the MIPS pipeline and the types of hazards, but without an interactive or visual component. 
As a general observation, all of the existing solutions above suffer from a lack of visual representation. Thus, this project aims to provide a slightly different perspective by creating an interactive, educational simulator that focuses on how instructions move through the pipeline and how hazards affect performance.

\section{Software Design Considerations}
The simulator will follow object-oriented design principles such as modularity, encapsulation, and separation of concerns. The architecture will clearly separate:
\begin{itemize}
    \item the execution engine (responsible for instruction handling and pipeline state),
    \item the data model (registers, memory, instructions), and
    \item the user interface layer (for visualization and user interaction).
\end{itemize}


\chapter{Analysis}\label{ch:analysis}

This chapter presents the theoretical foundations for the MIPS CPU simulator, detailing the hardware concepts and architectural mechanisms that will be modeled. The analysis covers the MIPS pipeline structure, instruction execution mechanics, hazard detection, and resolution techniques that form the conceptual basis for the simulator implementation.

\section{MIPS Pipeline Architecture}

\subsection{Pipeline Structure and Stage Definition}
The MIPS pipeline employs a five-stage architecture designed to maximize instruction throughput by enabling concurrent processing of multiple instructions. As illustrated in Figure~\ref{fig:pipeline}, each stage performs specialized operations while maintaining data flow through pipeline registers.

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.8\textwidth]{fig/pipeline.png}
    \caption{General structure of the 5-stage MIPS pipeline~\cite{website}.}
    \label{fig:pipeline}
\end{figure}

The five stages operate as follows:
\begin{itemize}
    \item \textbf{Instruction Fetch (IF):} Retrieves instructions from memory using the program counter and increments PC
    \item \textbf{Instruction Decode (ID):} Decodes instruction fields, reads register values, and generates control signals
    \item \textbf{Execute (EX):} Performs arithmetic/logical operations and calculates memory addresses
    \item \textbf{Memory Access (MEM):} Handles data memory reads/writes for load/store instructions
    \item \textbf{Write Back (WB):} Writes results back to the register file
\end{itemize}

\subsection{Instruction Parallelism}
The pipeline achieves performance gains through instruction-level parallelism, where multiple instructions occupy different stages simultaneously. Figure~\ref{fig:instructions_pipeline} demonstrates this overlapping execution pattern, showing how the pipeline maintains a steady flow of instruction completion once initially filled.

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.8\textwidth]{fig/instructions_pipeline.png}
    \caption{Concurrent instruction execution in the MIPS pipeline~\cite{website}.}
    \label{fig:instructions_pipeline}
\end{figure}

\section{Instruction Set Architecture}

\subsection{Instruction Formats and Encoding}
The simulator implements all three primary instruction formats, each with a fixed 32-bit encoding scheme as shown in Figure~\ref{fig:instruction_format}. This consistent formatting enables efficient decoding and execution across all instruction types.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{fig/instruction_format.png}
    \caption{MIPS instruction encoding formats~\cite{lectures}.}
    \label{fig:instruction_format}
\end{figure}

\subsection{Instruction Categories and Examples}
The supported instruction set includes:

\textbf{R-type (Register Operations):} 
\begin{itemize}
    \item \texttt{ADD, SUB, AND, OR, XOR, NOR, SLL, SRL, SLT}
    \item \textcolor{blue}{Example: \texttt{add \$t0, \$t1, \$t2} - Register addition}
\end{itemize}

\textbf{I-type (Immediate/Memory Operations):}
\begin{itemize}
    \item \texttt{ADDI, ANDI, ORI, SLTI, LW, SW, BEQ, BNE}  
    \item \textcolor{green!70!black}{Example: \texttt{lw \$t0, 4(\$sp)} - Memory load operation}
\end{itemize}

\textbf{J-type (Jump Operations):}
\begin{itemize}
    \item \texttt{J, JAL}
    \item \textcolor{red!80!black}{Example: \texttt{j main} - Unconditional jump}
\end{itemize}

\subsection{Register Transfer Level (RTL) Description}

The simulator models instruction execution at the register transfer level, describing the data movements and operations between pipeline stages for each instruction type.

\subsubsection{R-type Instructions RTL Description}
For R-type instructions such as \texttt{add \$rd, \$rs, \$rt}:
\begin{align*}
\text{IF:} & \quad \text{IR} \leftarrow \text{Mem[PC]}, \quad \text{PC} \leftarrow \text{PC} + 4 \\
\text{ID:} & \quad \text{A} \leftarrow \text{Reg[\$rs]}, \quad \text{B} \leftarrow \text{Reg[\$rt]}, \quad \text{Decode opcode} \\
\text{EX:} & \quad \text{ALUOutput} \leftarrow \text{A} \oplus \text{B} \quad \text{where } \oplus \text{ is the ALU operation} \\
\text{MEM:} & \quad \text{No memory operation} \\
\text{WB:} & \quad \text{Reg[\$rd]} \leftarrow \text{ALUOutput}
\end{align*}

\subsubsection{I-type Load/Store RTL Description}
For load instructions such as \texttt{lw \$rt, offset(\$rs)}:
\begin{align*}
\text{IF:} & \quad \text{IR} \leftarrow \text{Mem[PC]}, \quad \text{PC} \leftarrow \text{PC} + 4 \\
\text{ID:} & \quad \text{A} \leftarrow \text{Reg[\$rs]}, \quad \text{Sign-extend immediate} \\
\text{EX:} & \quad \text{ALUOutput} \leftarrow \text{A} + \text{SignExt(imm)} \\
\text{MEM:} & \quad \text{LMD} \leftarrow \text{Mem[ALUOutput]} \\
\text{WB:} & \quad \text{Reg[\$rt]} \leftarrow \text{LMD}
\end{align*}

For store instructions such as \texttt{sw \$rt, offset(\$rs)}:
\begin{align*}
\text{IF:} & \quad \text{IR} \leftarrow \text{Mem[PC]}, \quad \text{PC} \leftarrow \text{PC} + 4 \\
\text{ID:} & \quad \text{A} \leftarrow \text{Reg[\$rs]}, \quad \text{B} \leftarrow \text{Reg[\$rt]}, \quad \text{Sign-extend immediate} \\
\text{EX:} & \quad \text{ALUOutput} \leftarrow \text{A} + \text{SignExt(imm)} \\
\text{MEM:} & \quad \text{Mem[ALUOutput]} \leftarrow \text{B} \\
\text{WB:} & \quad \text{No register writeback}
\end{align*}

\subsubsection{Branch Instructions RTL Description}
For branch instructions such as \texttt{beq \$rs, \$rt, label}:
\begin{align*}
\text{IF:} & \quad \text{IR} \leftarrow \text{Mem[PC]}, \quad \text{PC} \leftarrow \text{PC} + 4 \\
\text{ID:} & \quad \text{A} \leftarrow \text{Reg[\$rs]}, \quad \text{B} \leftarrow \text{Reg[\$rt]}, \quad \text{Target} \leftarrow \text{PC} + (\text{imm} \ll 2) \\
\text{EX:} & \quad \text{Condition} \leftarrow (\text{A} = \text{B}), \quad \text{If Condition then PC} \leftarrow \text{Target} \\
\text{MEM:} & \quad \text{Pipeline flush if branch taken} \\
\text{WB:} & \quad \text{No register writeback}
\end{align*}

\subsubsection{Jump Instructions RTL Description}
For jump instructions such as \texttt{j target}:
\begin{align*}
\text{IF:} & \quad \text{IR} \leftarrow \text{Mem[PC]}, \quad \text{PC} \leftarrow \text{PC} + 4 \\
\text{ID:} & \quad \text{Target} \leftarrow (\text{PC}_{31:28} \parallel (\text{address} \ll 2)) \\
\text{EX:} & \quad \text{PC} \leftarrow \text{Target} \\
\text{MEM:} & \quad \text{Pipeline flush} \\
\text{WB:} & \quad \text{No register writeback}
\end{align*}

\subsubsection{Pipeline Register Transfers}
The data flow between stages is maintained through pipeline registers:
\begin{align*}
\text{IF/ID:} & \quad \text{IR, PC+4} \\
\text{ID/EX:} & \quad \text{A, B, SignExt(imm), Control signals} \\
\text{EX/MEM:} & \quad \text{ALUOutput, B, Control signals} \\
\text{MEM/WB:} & \quad \text{LMD, ALUOutput, Control signals}
\end{align*}

This RTL description provides the formal specification for instruction execution that guides the simulator implementation, ensuring accurate modeling of the MIPS pipeline behavior.

\subsection{Supported Instruction Set}
\label{subsec:supported-instructions}
The simulator implements 21 core MIPS instructions covering arithmetic, memory, and control flow operations:

\begin{table}[H]
\centering
\begin{tabularx}{0.9\textwidth}{|l|l|X|}
\hline
\textbf{Type} & \textbf{Instruction} & \textbf{Description} \\
\hline
\rowcolor{gray!10}
\multicolumn{3}{|c|}{\textbf{R-type Instructions (Register Operations)}} \\
\hline
ADD & \texttt{add rd, rs, rt} & Integer addition \\
SUB & \texttt{sub rd, rs, rt} & Integer subtraction \\
AND & \texttt{and rd, rs, rt} & Bitwise AND \\
OR & \texttt{or rd, rs, rt} & Bitwise OR \\
XOR & \texttt{xor rd, rs, rt} & Bitwise XOR \\
NOR & \texttt{nor rd, rs, rt} & Bitwise NOR \\
SLL & \texttt{sll rd, rt, shamt} & Shift left logical \\
SRL & \texttt{srl rd, rt, shamt} & Shift right logical \\
SLT & \texttt{slt rd, rs, rt} & Set less than (signed) \\
\hline
\rowcolor{gray!10}
\multicolumn{3}{|c|}{\textbf{I-type Instructions (Immediate/Memory Operations)}} \\
\hline
ADDI & \texttt{addi rt, rs, imm} & Add immediate \\
LW & \texttt{lw rt, offset(rs)} & Load word from memory \\
SW & \texttt{sw rt, offset(rs)} & Store word to memory \\
BEQ & \texttt{beq rs, rt, label} & Branch if equal \\
BNE & \texttt{bne rs, rt, label} & Branch if not equal \\
ORI & \texttt{ori rt, rs, imm} & Bitwise OR immediate \\
ANDI & \texttt{andi rt, rs, imm} & Bitwise AND immediate \\
SLTI & \texttt{slti rt, rs, imm} & Set less than immediate \\
\hline
\rowcolor{gray!10}
\multicolumn{3}{|c|}{\textbf{J-type Instructions (Jump Operations)}} \\
\hline
J & \texttt{j target} & Unconditional jump \\
JAL & \texttt{jal target} & Jump and link \\
\hline
\end{tabularx}
\caption{Complete instruction set supported by the simulator.}
\label{tab:instruction_set}
\end{table}

\section{Pipeline Hazard Mechanisms}

\subsection{Hazard Classification and Detection}
Pipeline hazards represent situations when the next instruction cannot be executed in the following clock cycle. Three types of hazards can be distinguished:

\begin{itemize}
    \item \textbf{Structural Hazards:} Arise from resource conflicts; when two instructions attempt to use the same hardware component at the same time. An example is shown in Figure~\ref{fig:structural_hazard}, where the Load and Instruction 3 both need to access the memory in the same cycle.

    \begin{figure}[H]
        \centering
        \includegraphics[width=0.6\textwidth]{fig/structural_hazard.png}
        \caption{Simultaneous memory access of two instructions in different stages~\cite{lectures}.}
        \label{fig:structural_hazard}
    \end{figure}

    \item \textbf{Data Hazards:} Occur when instructions depend on results from previous instructions still in the pipeline. Figure~\ref{fig:data_hazard} presents a Read-After-Write (RAW) hazard where the \texttt{and} instruction needs \$2 in cycle 3 (during ID stage) or cycle 4 (during EX stage), but the value won't be available until cycle 5.
    
    \begin{figure}[H]
        \centering
        \includegraphics[width=0.6\textwidth]{fig/data_hazard.png}
        \caption{RAW Data Hazard~\cite{lectures}.}
        \label{fig:data_hazard}
    \end{figure}
    
    \item \textbf{Control Hazards:} Result from branch and jump instructions altering the program flow; attempt to make a decision about program control flow before the condition has been evaluated and the new program counter target address computed. An example is detailed below:

    \begin{verbatim}
    Cycle 1:  beq $t0, $t1, label    # Branch instruction
    Cycle 2:  add $t2, $t3, $t4      # Instruction after branch
    Cycle 3:  lw $t5, 0($t6)         # Second instruction after branch  
    Cycle 4:  label: add $t7, $t8, $t9  # Branch target
    \end{verbatim}
    
\end{itemize}

\subsection{Hazard Resolution Algorithms}
The simulator implements all three hazards presented above, as well as several resolution strategies to maintain pipeline efficiency:

\textbf{Pipeline Stall Algorithm:}
\begin{enumerate}
    \item Identify unresolvable data or structural hazards
    \item Insert pipeline bubbles by disabling register writes and PC updates
    \item Maintain pipeline state until hazard resolves
\end{enumerate}

\textbf{Forwarding Algorithm:}
\begin{enumerate}
    \item Detect data dependencies between instructions in EX/MEM/WB and ID stages
    \item Route results directly from producing stages to consuming stages
    \item Bypass register file access when newer data is available
\end{enumerate}

\textbf{Branch Prediction Strategy:}
\begin{enumerate}
    \item Assume branch not taken for simple prediction
    \item Flush pipeline if prediction proves incorrect
    \item Redirect instruction fetch to correct target address
    \item \textbf{Penalty:} 2 clock cycles lost when the branch is taken
\end{enumerate}

\section{Processor Components Architecture}

\subsection{Control Unit Design}
The control unit generates control signals across all pipeline stages based on decoded information from the instruction opcode and/or function field. Its operation follows this sequence:

\begin{enumerate}
    \item Analyze opcode and function fields during ID stage
    \item Generate stage-specific control signals (RegWrite, MemRead, MemWrite, ALUOp, etc.)
    \item Propagate control signals through pipeline registers
    \item Deactivate signals for instructions that don't use specific stages
\end{enumerate}

The data-path with control signals is depicted in Figure~\ref{fig:control_datapath}. Each of the described steps can be observed in blue.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{fig/control_unit.png}
    \caption{MIPS Pipeline Data-Path with control signals~\cite{website}.}
    \label{fig:control_datapath}
\end{figure}

\subsection{ALU Operations and Functionality}
The Arithmetic Logic Unit performs computations based on control signals and operand inputs. Key operations include:
\begin{itemize}
    \item Arithmetic: Addition, subtraction with overflow detection
    \item Logical: AND, OR, XOR, NOR operations
    \item Comparison: Set-less-than for signed and unsigned values
    \item Shift: Logical and arithmetic shift operations
\end{itemize}

\subsection{Memory Hierarchy and Register Organization}
The memory subsystem uses separate instruction and data memories following the Harvard architecture principle to avoid structural hazards. This separation allows simultaneous instruction fetch and data memory access in different pipeline stages.

\subsubsection{Register File Organization}
The MIPS architecture features 32 general-purpose 32-bit registers.

The register file organization supports pipeline operation through:
\begin{itemize}
    \item Dual read ports for simultaneous reading of two source operands during ID stage
    \item Single write port for register updates during WB stage
    \item The \texttt{\$zero} register is hardwired to value 0 for efficient constant generation
    \item Register bypass logic to handle RAW data hazards between pipeline stages
\end{itemize}

\subsubsection{Memory Organization}
The memory system features:
\begin{itemize}
    \item Byte-addressable 32-bit address space
    \item Word-aligned memory accesses (addresses divisible by 4)
    \item Selectable endianness
    \item Separate instruction and data memories to prevent structural hazards
    \item Memory-mapped I/O regions for input/output operations
\end{itemize}

\subsection{Simulation Methodology}

The simulator models the MIPS pipeline using a discrete, clock-driven approach. Each clock cycle represents a complete synchronization point where all pipeline stages update their state and data flow concurrently.

\subsubsection{Simulation Approach} 

\begin{itemize}
    \item \textbf{Clock-driven Execution:} The simulation advances one clock cycle at a time.
    \item \textbf{Pipeline Synchronization:} All stages (IF, ID, EX, MEM, WB) execute in parallel, maintaining consistent instruction flow.
    \item \textbf{Event Handling:} During each cycle, instructions progress through stages, hazards are managed, architectural state is updated, and the visualization reflects the new system state.
\end{itemize}

\subsubsection{Clock Cycle Execution Sequence}

Each clock cycle involves the following steps:

\begin{enumerate}
    \item Propagate instructions through pipeline stages (IF → ID → EX → MEM → WB)
    \item Detect and resolve hazards using forwarding or stalling
    \item Handle control flow changes and flush mispredicted instructions
    \item Update registers and memory with computed results
    \item Refresh the visualization and increment the simulation clock
\end{enumerate}


\chapter{Design}\label{ch:design}

This chapter presents the design and architectural structure of the MIPS pipeline simulator. Building on the theoretical concepts described in Chapter~\ref{ch:analysis}, this section outlines how those ideas are implemented in software.

\section{System Architecture Overview}

The simulator follows a modular, layered architecture composed of three main layers:

\begin{itemize}
    \item \textbf{Simulation Engine Layer} – Implements the core logic of instruction execution and hazard management.
    \item \textbf{Data Model Layer} – Represents the architectural state of the processor, including registers, memory, and pipeline registers.
    \item \textbf{Presentation Layer} – Provides visualization and interaction for the user through graphical components.
\end{itemize}

The layered approach promotes separation of concerns, making the design easy to maintain and extend in the future.

\section{User Interactions with the Simulator}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.3\textwidth]{fig/use_case_diagram.png}
    \caption{Use case diagram showing user interactions with the simulator.}
    \label{fig:use_case}
\end{figure}

As illustrated in Figure~\ref{fig:use_case}, users can load a MIPS program written in assembly language, execute it step-by-step or continuously, inspect the pipeline state, and enable or disable hazard resolution mechanisms. The main interactions include program loading (assembly code input), execution control, state inspection, and simulation reset.

\section{Simulator Components}

\begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{fig/class_diagram.png}
    \caption{Class diagram showing main system components and their relationships.}
    \label{fig:class_diagram}
\end{figure}

Figure~\ref{fig:class_diagram} illustrates the system's class structure. The simulator is centered around the \textbf{PipelineController}, which manages clock cycles, pipeline stage coordination, and hazard handling. Each pipeline stage—\textbf{FetchStage}, \textbf{DecodeStage}, \textbf{ExecuteStage}, \textbf{MemoryStage}, and \textbf{WriteBackStage}—is represented by a dedicated class responsible for its specific functionality.

\subsection{Core Components}

\textbf{PipelineController}

Coordinates overall execution, synchronizing pipeline stages each cycle. It interfaces with the hazard detection and forwarding units to ensure correct instruction flow.

\vspace{1ex} 

\textbf{HazardDetectionUnit}, \textbf{ForwardingUnit}, and \textbf{StallUnit}

These units collectively handle instruction dependencies and pipeline control. The \texttt{HazardDetectionUnit} identifies data, control, and structural hazards during each clock cycle. When a hazard cannot be resolved through data forwarding, the \texttt{StallUnit} introduces pipeline stalls to preserve correct execution order. The \texttt{ForwardingUnit} handles read-after-write (RAW) hazards by routing results directly between stages whenever possible.

\vspace{1ex}

\textbf{Pipeline Registers}

Classes such as \textbf{IF\_ID\_Register}, \textbf{ID\_EX\_Register}, \textbf{EX\_MEM\_Register}, and \textbf{MEM\_WB\_Register} hold intermediate data between stages, encapsulating control signals and operand values for the next clock cycle.

\vspace{2ex}

\subsection{Architectural State Components}

\textbf{\textbf{RegisterFile}}

Stores the 32 general-purpose registers. Provides simultaneous read ports and one write port for concurrent access during pipeline execution.

\vspace{1ex}

\textbf{\textbf{Memory Subsystem}}

Implemented as \textbf{InstructionMemory} and \textbf{DataMemory} classes, maintains separation between instruction fetch and data access paths.

\vspace{1ex}

\textbf{ProgramCounter}

Tracks the address of the instruction currently being fetched. Updated each cycle or redirected in case of branch instructions.

\vspace{1ex}

\textbf{ControlUnit}

Generates the control signals required by each instruction type, influencing multiplexers, ALU operations, and memory control lines.

\vspace{1ex}

\textbf{Program Loading Components}

The \textbf{Assembler} and \textbf{ProgramLoader} classes handle program input and initialization. The \textbf{Assembler} converts human-readable MIPS assembly code into binary machine code instructions, supporting label resolution, register name parsing, and instruction encoding. The \textbf{ProgramLoader} manages the loading of assembled instructions into instruction memory, validating addresses and managing program state initialization.

\subsection{Pipeline Stages}

Each stage encapsulates its corresponding MIPS pipeline function:

\begin{itemize}
    \item \textbf{FetchStage}: Retrieves the next instruction from \textbf{InstructionMemory}.
    \item \textbf{DecodeStage}: Decodes instruction fields and reads operand values from the \textbf{RegisterFile}.
    \item \textbf{ExecuteStage}: Performs arithmetic or logical operations through the ALU.
    \item \textbf{MemoryStage}: Accesses or updates data memory for load and store instructions.
    \item \textbf{WriteBackStage}: Writes computed results back into the register file.
\end{itemize}

\section{Data Flow and Execution Sequence}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.3\textwidth]{fig/data_flow.png}
    \caption{Data flow diagram illustrating information exchange between components.}
    \label{fig:data_flow}
\end{figure}

As depicted in Figure~\ref{fig:data_flow}, the simulation proceeds in a sequence of discrete clock cycles managed by the \texttt{PipelineController}. Each cycle involves:

\begin{enumerate}
    \item Fetching the next instruction.
    \item Decoding and preparing operands.
    \item Executing ALU or branch operations.
    \item Accessing memory (if required).
    \item Writing results to registers.
\end{enumerate}

Hazard detection and forwarding operate concurrently during each cycle to maintain correctness.

\section{User Interface Components}

The visualization layer presents the simulator's internal state in real-time. It includes:

\begin{itemize}
    \item \textbf{PipelineVisualizer}: Displays the content and status of each pipeline stage.
    \item \textbf{RegisterDisplay}: Shows current register values and highlights recent changes.
    \item \textbf{DataMemoryDisplay}: Shows the current contents of the data memory.
    \item \textbf{ControlPanel}: Provides execution controls for stepping, running, pausing, and resetting the simulation.
\end{itemize}

These components are updated after every clock cycle, ensuring synchronized feedback between the simulation engine and the user interface.

\section{Component Interaction Summary}

During each clock cycle, the following sequence occurs:
\begin{itemize}
    \item The \textbf{PipelineController} triggers all stage modules.
    \item Pipeline registers propagate intermediate results.
    \item The \textbf{HazardDetectionUnit} and \textbf{ForwardingUnit} adjust data paths as needed.
    \item Architectural state components (\textbf{RegisterFile}, \textbf{Memory}, \textbf{ProgramCounter}) are updated.
    \item Visualization components refresh to display the new state.
\end{itemize}


\chapter{Implementation}\label{ch:implementation}

This chapter presents the implementation of the simulator, with a focus on the Java backend and the web API for frontend communication. The implementation follows the architectural design of Chapter~\ref{ch: design} to build a functioning simulation engine with an intuitive user interface.

\section{Backend Implementation}
\subsection{Overall Architecture}

The backend implementation follows a modular, object-oriented architecture that closely mirrors the MIPS pipeline structure. The system is organized into several key packages:

\begin{itemize}
    \item \textbf{model.instruction:} Contains classes representing MIPS instructions (R-type, I-type, J-type) and their decoding logic.
    \item \textbf{model.cpu:} Implements CPU state components, including the register file, program counter, and memory subsystems.
    \item \textbf{model.control:} Houses the control unit, hazard detection unit, forwarding unit, and stall unit.
    \item \textbf{model.pipeline.stages:} Contains the five pipeline stage implementations (Fetch, Decode, Execute, Memory, WriteBack).
    \item \textbf{model.pipeline.registers:} Implements pipeline registers that buffer data between stages.
    \item \textbf{model.pipeline.state:} Contains classes responsible for capturing and representing the current state of the pipeline stages during simulation. These classes provide a snapshot of pipeline activity, enabling visualization and state tracking throughout the execution process.
    \item \textbf{simulator:} Provides the main simulation engine, clock, and API server (\textbf{simulator.api}) for frontend communication.
\end{itemize}

\subsection{Instruction Implementation}

Each instruction is represented as an object-oriented model, following the structure and behavior of its corresponding instruction format (R, I, or J-type). All instruction types extend a common abstract base class, \textbf{Instruction}, which provides the binary representation and the opcode, while subclasses handle specific field decoding.

\begin{lstlisting}[style=javaStyle]
public abstract class Instruction {
    private final int opcode;
    private final int binary;

    protected Instruction(int opcode, int binary) {
        this.opcode = opcode;
        this.binary = binary;
    }

    public int getOpcode() { return opcode; }
    public int getBinary() { return binary; }

    public abstract void decodeFields();
}
\end{lstlisting}

\subsection*{R-Type Instruction}

The \textbf{RTypeInstruction} class extracts its fields (two source registers, destination register, shift amount and function code) using bit shifting and masking:

\begin{lstlisting}[style=javaStyle]
@Override
public void decodeFields() {
    int binary = getBinary();
    rs = (binary >> 21) & 0x1F;
    rt = (binary >> 16) & 0x1F;
    rd = (binary >> 11) & 0x1F;
    shamt = (binary >> 6) & 0x1F;
    func = binary & 0x3F;
}
\end{lstlisting}

\subsection*{I-Type Instruction}

The \textbf{ITypeInstruction} class decodes the 16-bit immediate field, ensuring sign-extension where necessary:

\begin{lstlisting}[style=javaStyle]
@Override
public void decodeFields() {
    int binary = getBinary();
    rs = (binary >> 21) & 0x1F;
    rt = (binary >> 16) & 0x1F;
    immediate = binary & 0xFFFF;
    if ((immediate & 0x8000) != 0) immediate |= 0xFFFF0000; // sign-extend
}
\end{lstlisting}

\subsection*{J-Type Instruction}

The \texttt{JTypeInstruction} class simply extracts the target address as:

\begin{lstlisting}[style=javaStyle]
@Override
public void decodeFields() {
    address = getBinary() & 0x03FFFFFF;
}
\end{lstlisting}

\subsection{Memory Subsystem}

\subsection*{Instruction Memory}
The \textbf{InstructionMemory} class stores and provides access to instruction objects in a fixed-size, word-aligned memory array (4 KB = 1024 words). The class provides methods for accessing the contents:
\begin{itemize}
    \item Call \textbf{setInstruction(int, Instruction)} to store an instruction at a given address.
    \item Call \textbf{fetch(int)} to retrieve the instruction from a given address.
\end{itemize}
If an address is outside the valid range (0--4092), \textbf{fetch()} returns \texttt{null} and \textbf{setInstruction()} does nothing.

\subsection*{Data Memory}
The \textbf{DataMemory} class provides word-aligned load and store operations for reading and writing 32-bit values through \textbf{loadWord(int)} and \textbf{storeWord(int, int)} methods. Out-of-range addresses are safely ignored:
\begin{itemize}
    \item \texttt{loadWord(int)} returns 0 for invalid addresses.
    \item \texttt{storeWord(int, int)} does nothing for invalid addresses.
\end{itemize}

\subsection{CPU State Components}
\subsection*{Register File}

The \textbf{RegisterFile} class models the 32 general-purpose registers in the MIPS CPU through an Integer array. Register 0 (\$zero) is immutable and always holds the value 0. Other registers can be read and written using \textbf{get()} and \textbf{set()} methods.

\subsection*{Program Counter}

The \textbf{ProgramCounter} class models the program counter (PC) of the processor, tracking the address of the current instruction being executed, and providing additional methods to update it.
\begin{itemize}
    \item The program counter (\textbf{pc}) is stored as a 32-bit integer.
    \item The PC can be read using the \textbf{get()} method.
    \item The PC can be set directly using the \textbf{set(int value)} method.
    \item The PC can be advanced to the next instruction using \textbf{increment()}, which increases it by 4 (word-aligned).
    \item An arbitrary offset can be added to the PC using \textbf{addOffset(int offset)}.
\end{itemize}

\subsection*{CPU State}

The \textbf{CPUState} class acts as a central container for the CPU's state, allowing pipeline stages or simulator code to access and modify registers, memory, and the PC. The instruction memory is provided via the constructor, while the other components are initialized internally.
\begin{lstlisting}[style=javaStyle]
public class CPUState {
    public RegisterFile registerFile = new RegisterFile();
    public InstructionMemory instructionMemory;
    public DataMemory dataMemory = new DataMemory();
    public ProgramCounter pc = new ProgramCounter();
    
    public CPUState(InstructionMemory instrMem) {
        this.instructionMemory = instrMem;
    }
}
\end{lstlisting}

\subsection{Control Handling}

\subsection*{Control Unit}

The \textbf{ControlUnit} class implements the control logic designed in Section~\ref{ch:design}. It generates control signals based on the instruction opcode to coordinate data flow and ALU operations for the full instruction set.

\paragraph{Control Signals}
\begin{itemize}
    \item \texttt{regWrite} --- writes to the register file
    \item \texttt{memToReg} --- selects memory data vs ALU result
    \item \texttt{branch} --- branch instruction
    \item \texttt{memRead} --- load instruction
    \item \texttt{memWrite} --- store instruction
    \item \texttt{regDst} --- selects destination register (rd vs rt)
    \item \texttt{aluSrc} --- selects ALU operand (immediate vs register)
    \item \texttt{aluOp} --- ALU operation code
    \item \texttt{jump} --- jump instruction
\end{itemize}

\subsection*{Hazard Detection Unit}

The \textbf{HazardDetectionUnit} implements the hazard detection mechanism described in the design. It monitors the \textbf{PipelineRegisters} to detect data, control, and structural hazards through dedicated methods: \textbf{checkDataHazards(regs)}, \textbf{checkControlHazards(regs)}, \textbf{checkStructuralHazards(regs)}. 

It reports detected hazards through a \textbf{HazardReport} object, which lists all detected conditions and indicates whether stalling or flushing is required. Supporting units such as \textbf{ForwardingUnit} and \textbf{StallUnit} use this information to apply the appropriate solution.

\subsection*{Forwarding Unit}

The \textbf{ForwardingUnit} resolves data hazards by forwarding results from later pipeline stages to the ALU inputs in the \textbf{EX} stage. It compares the source registers (\texttt{Rs}, \texttt{Rt}) of the instruction in the \textbf{ID/EX} pipeline register with the destination registers of the instructions in the \textbf{EX/MEM} and \textbf{MEM/WB} pipeline registers. 

If a match is detected and the corresponding instruction writes to a register (\texttt{RegWrite = 1}) other than \texttt{\$zero}, the unit sets the forwarding control signals as follows:

\begin{itemize}
    \item \texttt{10} --- Forward from \textbf{EX/MEM} stage
    \item \texttt{01} --- Forward from \textbf{MEM/WB} stage
    \item \texttt{00} --- No forwarding
\end{itemize}

The forwarding signals are encapsulated in the \textbf{ForwardingResult} structure:
\begin{lstlisting}[style=javaStyle]
public static class ForwardingResult {
    public final int forwardA;
    public final int forwardB;

    public ForwardingResult(int forwardA, int forwardB) {
        this.forwardA = forwardA;
        this.forwardB = forwardB;
    }
}
\end{lstlisting}

\subsection*{Stall Unit}

The \textbf{StallUnit} receives hazard detection signals from the \textbf{HazardDetectionUnit} and issues stall control signals when a \textit{load-use hazard} is detected.

If a stall is required, the unit:
\begin{itemize}
    \item Prevents updates to the \textbf{PC} and \textbf{IF/ID} pipeline register
    \item Clears the control signals in the \textbf{ID/EX} pipeline register to insert a \texttt{bubble} (a no-operation)
\end{itemize}

The control signals are encapsulated in the \textbf{StallControl} structure:
\begin{lstlisting}[style=javaStyle]
public static class StallControl {
    public final boolean stall;     // true if stalling
    public final boolean pcWrite;   // enable PC update
    public final boolean ifidWrite; // enable IF/ID update
    public final boolean idExClear; // flush ID/EX (insert bubble)
}
\end{lstlisting}

\subsection{Pipeline Representation}
\subsection*{Pipeline Stages}

The MIPS CPU pipeline is implemented through five concrete classes, each derived from the \textbf{PipelineStage} interface:
\begin{lstlisting}[style=javaStyle]
public interface PipelineStage {
    void process(CPUState state, PipelineRegisters regs);
}
\end{lstlisting}

Each stage implements the functionality outlined in Section~\ref{ch:design}:

\begin{itemize}
    \item \textbf{Fetch (IF)} --- Retrieves the next instruction from instruction memory using the current \textbf{PC}, computes \texttt{PC+4}, and stores both the instruction and the incremented PC value into the \textbf{IF/ID} pipeline register.
    
    \item \textbf{Decode (ID)} --- Decodes the fetched instruction, reads operand values from the register file, and generates control signals via the \textbf{ControlUnit}. For jump or branch instructions, it computes the potential target address.
    
    \item \textbf{Execute (EX)} --- Performs arithmetic and logical operations using the ALU, computes branch target addresses, determines the destination register, evaluates branch conditions, and applies data forwarding to resolve read-after-write (RAW) hazards.
    
    \item \textbf{Memory Access (MEM)} --- Performs data memory operations (\texttt{lw}, \texttt{sw}) and finalizes branch resolution. If a branch is taken, it updates the PC and triggers pipeline flushes.
    
    \item \textbf{Write Back (WB)} --- Writes the result of an ALU operation or a value loaded from memory back into the register file.
\end{itemize}

\subsection*{Pipeline Registers}

The pipeline register classes implement the buffering mechanism between pipeline stages:

\begin{itemize}
    \item \textbf{PipelineRegisters}: A container class that holds all stage-specific registers.
    \begin{lstlisting}[style=javaStyle]
    public class PipelineRegisters {
        public IF_ID_Register IF_ID = new IF_ID_Register();
        public ID_EX_Register ID_EX = new ID_EX_Register();
        public EX_MEM_Register EX_MEM = new EX_MEM_Register();
        public MEM_WB_Register MEM_WB = new MEM_WB_Register();
    }
    \end{lstlisting}

    \item \textbf{IF\_ID\_Register}: Stores the fetched instruction and PC for decode stage.

    \text{Fields: } \texttt{instruction, pc}

    \item \textbf{ID\_EX\_Register}: Holds data read from register file, sign-extended immediate values, and control signals.

    \text{Fields: } \texttt{readData1, readData2, signExtendedImm, pcPlus4, rs, rt, rd, regWrite, memToReg, branch, memRead, memWrite, regDst, aluSrc, aluOp, instruction}

    \item \textbf{EX\_MEM\_Register}: Contains ALU results, memory write data, branch information, and control signals.

    \text{Fields: } \texttt{aluResult, zeroFlag, writeData, branchTarget, branchTaken, destReg, regWrite, memToReg, branch, memRead, memWrite, instruction}

    \item \textbf{MEM\_WB\_Register}: Holds data for write-back to register file.

    \text{Fields: } \texttt{aluResult, memData, destReg, regWrite, memToReg, instruction}
\end{itemize}

The method \textbf{getWriteData()} selects between ALU result and memory data based on the \texttt{memToReg} signal.


\subsection*{Pipeline State}

The pipeline state is managed through three core classes that capture the operational status of the pipeline for visualization and monitoring:

\begin{itemize}
    \item \textbf{PipelineSnapshot} --- Captures a complete snapshot of all five pipeline stages at a given clock cycle, enabling comprehensive state visualization and API serialization.
    
    \begin{lstlisting}[style=javaStyle]
    public class PipelineSnapshot {
        private final StageInfo ifStage, idStage, exStage, memStage, wbStage;
        // Constructor and getters for all five stages
    }
    \end{lstlisting}
    
    \item \textbf{StageInfo} --- Represents the state and content of an individual pipeline stage, combining operational status with the current instruction being processed.

    \begin{lstlisting}[style=javaStyle]
    public class StageInfo {
        private final StageState state;
        private final Instruction instruction;
    }
    \end{lstlisting}

    
    \item \textbf{StageState} --- Defines the operational modes for pipeline stages, including normal execution (\texttt{INSTR}), hazard-induced stalls (\texttt{STALL}), inserted bubbles (\texttt{BUBBLE}), branch-related flushes (\texttt{FLUSH}), and empty states (\texttt{EMPTY}).

    \begin{lstlisting}[style=javaStyle]
    public enum StageState {
        INSTR, STALL, BUBBLE, FLUSH, EMPTY
    }
    \end{lstlisting}
\end{itemize}
\subsection{The Simulation Engine}

\subsection*{Pipeline Controller}

The \textbf{PipelineController} implements the central coordination logic for the 5-stage MIPS pipeline, integrating CPU state and pipeline registers to simulate concurrent instruction execution.

\begin{lstlisting}[style=javaStyle]
public class PipelineController {
    private final CPUState cpuState;
    private final PipelineRegisters pipelineRegisters = new PipelineRegisters();
    private final StallUnit stallUnit = new StallUnit();
    
    private final FetchStage fetch = new FetchStage();
    private final DecodeStage decode = new DecodeStage();
    private final ExecuteStage execute = new ExecuteStage();
    private final MemoryStage memory = new MemoryStage();
    private final WriteBackStage writeBack = new WriteBackStage();
    
    public void runCycle() {
        // processes each stage
    }
}
\end{lstlisting}

\paragraph{Pipeline Operation:}
The controller processes stages in reverse order (WB $\rightarrow$ MEM $\rightarrow$ EX $\rightarrow$ ID $\rightarrow$ IF) to ensure write-back occurs before subsequent reads. Each cycle, it checks for hazards, applies stalls if needed, and updates pipeline registers.

\paragraph{Hazard Handling:}
\begin{itemize}
    \item \textbf{Load-Use Hazards:} Detected by the \textbf{StallUnit}, which stalls the pipeline by freezing the \textbf{PC} and \textbf{IF/ID} register updates and clearing control signals in \textbf{ID/EX} to insert a bubble.
    \item \textbf{Control Hazards:} Branch instructions follow a \textit{predict-not-taken} policy. If a branch is taken, the controller flushes \textbf{IF/ID} and \textbf{ID/EX} registers, introducing a two-cycle penalty.
\end{itemize}

\subsection*{Clock}

The \textbf{Clock} class simulates the global clock of the MIPS pipeline, advancing the pipeline cycle by cycle through the \textbf{PipelineController}.

\begin{lstlisting}[style=javaStyle]
public class Clock {
    private int cycle = 0;
    private final PipelineController pipelineController;

    public Clock(PipelineController pipelineController) {
        this.pipelineController = pipelineController;
    }

    public void tick() {
        pipelineController.cycle();
        cycle++;
    }

    public int getCycle() { return cycle; }

    public void run(int n) {
        for (int i = 0; i < n; i++) tick();
    }
}
\end{lstlisting}

The \textbf{tick()} method advances the simulation by one clock cycle, while \textbf{run(int n)} executes multiple cycles in sequence, supporting both step-by-step and continuous execution modes.

\subsection{Program Loading and Instruction Parsing}
\subsection*{Program Loader}

The \textbf{ProgramLoader} class handles initialization and loading of MIPS programs into instruction memory, supporting multiple input formats:

\begin{itemize}
    \item \textbf{Assembly Code:} Human-readable MIPS assembly language instructions
    \item \textbf{Integer Array:} Direct 32-bit integer values representing binary instruction words
\end{itemize}

Key features include:
\begin{itemize}
    \item \textbf{Assembly Code Processing:} Converts assembly language to binary machine code using the \textbf{Assembler} class before loading into instruction memory
    \item \textbf{Instruction Parsing:} examines the 6 most significant bits (opcode) to determine instruction format.
    \begin{lstlisting}[style=javaStyle]
    public static Instruction parseInstruction(int binaryWord) {
        int opcode = (binaryWord >> 26) & 0x3F;
        
        if (opcode == 0x00) {
            return new RTypeInstruction(opcode, binaryWord);
        } else if (opcode == 0x02 || opcode == 0x03) {
            return new JTypeInstruction(opcode, binaryWord);
        } else {
            return new ITypeInstruction(opcode, binaryWord);
        }
    }
    \end{lstlisting}
    \item \textbf{Address Validation:} Ensures instruction addresses are word-aligned and within memory bounds
    \item \textbf{Bounds Checking:} Prevents loading instructions beyond memory capacity
    \item \textbf{Warning System:} Collects warnings for out-of-bounds instructions without failing the load operation
    \item \textbf{State Management:} Provides methods to reset CPU state
\end{itemize}

The \textbf{loadFromAssembly()} method processes assembly code input:
\begin{lstlisting}[style=javaStyle]
public static ProgramLoadResult loadFromAssembly(
    CPUState state, String[] assemblyLines, int startAddress) {
    validateStartAddress(startAddress);
    
    Assembler.AssemblyResult asmResult = Assembler.assemble(assemblyLines, startAddress);
    
    if (!asmResult.errors.isEmpty()) {
        throw new IllegalArgumentException("Assembly errors: " + 
            String.join("; ", asmResult.errors));
    }
    
    int[] words = asmResult.machineCode.stream()
        .mapToInt(Integer::intValue).toArray();
    
    return loadFromIntArray(state, words, startAddress);
}
\end{lstlisting}

The \textbf{ProgramLoadResult} class encapsulates load operation outcomes:
\begin{itemize}
    \item Number of successfully loaded instructions
    \item Start and end addresses of the loaded program
    \item List of warnings generated during loading
\end{itemize}

\subsection*{Assembler}

The \textbf{Assembler} class provides functionality to convert human-readable MIPS assembly code into binary machine code instructions. This enables users to write programs in assembly language rather than requiring manual binary or hexadecimal encoding of instructions.

\paragraph{Assembly Language Support:}

The assembler supports the complete instruction set implemented by the simulator, including:

\begin{itemize}
    \item \textbf{R-type instructions:} \texttt{add}, \texttt{sub}, \texttt{and}, \texttt{or}, \texttt{xor}, \texttt{nor}, \texttt{sll}, \texttt{srl}, \texttt{slt}
    \item \textbf{I-type instructions:} \texttt{addi}, \texttt{andi}, \texttt{ori}, \texttt{slti}, \texttt{lw}, \texttt{sw}, \texttt{beq}, \texttt{bne}
    \item \textbf{J-type instructions:} \texttt{j}, \texttt{jal}
\end{itemize}

\paragraph{Register Name Resolution:}

The assembler maintains a comprehensive mapping of MIPS register names to their numeric encodings, supporting both standard names and numeric aliases:

\begin{lstlisting}[style=javaStyle]
REGISTER_MAP.put("$zero", 0); REGISTER_MAP.put("$0", 0);
REGISTER_MAP.put("$t0", 8); REGISTER_MAP.put("$8", 8);
REGISTER_MAP.put("$s0", 16); REGISTER_MAP.put("$16", 16);
// ... all 32 registers with both name and numeric forms
\end{lstlisting}

This allows flexible register specification, accepting either \texttt{\$t0} or \texttt{\$8} for the same register, improving code readability and compatibility with different assembly syntax conventions.

\paragraph{Label Processing:}

The assembler implements a two-pass algorithm to handle labels for branch and jump instructions:

\begin{enumerate}
    \item \textbf{First Pass:} Scans all assembly lines to identify label definitions (lines ending with \texttt{:}) and builds a symbol table mapping label names to their instruction addresses.
    \item \textbf{Second Pass:} Assembles instructions, resolving label references in branch and jump instructions by computing relative offsets or absolute addresses.
\end{enumerate}

For branch instructions (\texttt{beq}, \texttt{bne}), the assembler calculates the relative offset from the current instruction to the target label:

\begin{lstlisting}[style=javaStyle]
if (labels.containsKey(parts.get(3))) {
    int targetAddress = labels.get(parts.get(3));
    offset = ((targetAddress - (address + 4)) / 4) & 0xFFFF;
}
\end{lstlisting}

For jump instructions (\texttt{j}, \texttt{jal}), the target address is encoded as an absolute word address:

\begin{lstlisting}[style=javaStyle]
if (labels.containsKey(parts.get(1))) {
    address = labels.get(parts.get(1)) / 4;
}
address &= 0x3FFFFFF;
return (info.opcode << 26) | address;
\end{lstlisting}

\paragraph{Instruction Format Handling:}

The assembler parses and encodes each instruction type according to its format:

\textbf{R-type Instructions:} The assembler extracts destination register (\texttt{rd}), source registers (\texttt{rs}, \texttt{rt}), shift amount (for \texttt{sll}/\texttt{srl}), and function code, then encodes them into the 32-bit instruction word:

\begin{lstlisting}[style=javaStyle]
// Standard R-type: op $rd, $rs, $rt
return (info.opcode << 26) | (rs << 21) | (rt << 16) | 
       (rd << 11) | info.funct;

// Shift instructions: op $rd, $rt, shamt
return (info.opcode << 26) | (rt << 16) | (rd << 11) | 
       (shamt << 6) | info.funct;
\end{lstlisting}

\textbf{I-type Instructions:} Handles three variants:
\begin{itemize}
    \item \textbf{Load/Store:} \texttt{lw/sw \$rt, offset(\$rs)} - encodes base register, destination/source register, and 16-bit signed offset
    \item \textbf{Branch:} \texttt{beq/bne \$rs, \$rt, label} - encodes source registers and computed branch offset
    \item \textbf{Immediate:} \texttt{addi/andi/ori/slti \$rt, \$rs, imm} - encodes registers and 16-bit immediate value
\end{itemize}

\textbf{J-type Instructions:} Encodes the 26-bit target address for \texttt{j} and \texttt{jal} instructions.

\paragraph{Input Processing Features:}

The assembler includes robust input processing capabilities:

\begin{itemize}
    \item \textbf{Comment Handling:} Strips comments (text following \texttt{\#}) from assembly lines
    \item \textbf{Whitespace Tolerance:} Handles flexible spacing and formatting, including instructions with varying amounts of whitespace
    \item \textbf{Case Insensitivity:} Accepts instruction mnemonics and register names in any case (e.g., \texttt{ADD}, \texttt{add}, \texttt{Add})
    \item \textbf{Immediate Value Parsing:} Supports both decimal and hexadecimal immediate values (e.g., \texttt{100}, \texttt{0x64}, \texttt{0xFF})
    \item \textbf{Parentheses Flexibility:} Handles memory addressing with flexible spacing: \texttt{lw \$t0, 100(\$s1)} or \texttt{lw \$t0, 100 ( \$s1 )}
\end{itemize}

\paragraph{Error Reporting:}

The assembler provides comprehensive error reporting through the \textbf{AssemblyResult} class:

\begin{lstlisting}[style=javaStyle]
public static class AssemblyResult {
    public final List<Integer> machineCode;
    public final List<String> errors;
}
\end{lstlisting}

Errors are collected per-line, allowing partial assembly to proceed even when some instructions contain errors. Error messages include:
\begin{itemize}
    \item Unknown instruction mnemonics
    \item Invalid register names
    \item Malformed instruction syntax (missing operands, incorrect format)
    \item Invalid immediate values (non-numeric strings, out-of-range values)
\end{itemize}

\paragraph{Usage Example:}

The assembler is invoked with an array of assembly lines and a starting address:

\begin{lstlisting}[style=javaStyle]
String[] assembly = {
    "main:",
    "    addi $t0, $zero, 10",
    "    addi $t1, $zero, 0",
    "loop:",
    "    beq $t0, $zero, end",
    "    addi $t1, $t1, 1",
    "    addi $t0, $t0, -1",
    "    j loop",
    "end:",
    "    sw $t1, 0($sp)"
};

Assembler.AssemblyResult result = Assembler.assemble(assembly, 0x00400000);
\end{lstlisting}

The resulting \textbf{machineCode} list contains 32-bit binary instruction words ready for loading into instruction memory via the \textbf{ProgramLoader}.

\subsection{API Server and Frontend Integration}

To enable web-based interaction with the simulator, a lightweight HTTP API server was implemented using Java's built-in \textbf{HttpServer}. This API provides a RESTful interface for controlling the simulation and querying CPU state.

\subsection*{API Architecture}

The \textbf{ApiServer} class manages HTTP request handling and coordinates between the simulation engine and external clients. It maintains references to the \textbf{HttpServer} object and \textbf{ServerContext}.

\begin{lstlisting}[style=javaStyle]
public class ApiServer {
    private final HttpServer server;
    private final ServerContext context;
    
    public ApiServer(int port) throws IOException {
		CPUState cpuState = new CPUState(new InstructionMemory());
		PipelineController controller = new PipelineController(cpuState);
		Clock clock = new Clock(controller);
		this.context = new ServerContext(cpuState, controller, clock);

		this.server = HttpServer.create(new InetSocketAddress(port), 0);

		server.createContext("/api/load", new LoadHandler(context));
		server.createContext("/api/step", new StepHandler(context));
		server.createContext("/api/state", new StateHandler(context));
		server.createContext("/api/reset", new ResetHandler(context));
		server.createContext("/api/health", new HealthHandler());

		server.setExecutor(null);
	}
}
\end{lstlisting}

\subsection*{Server Context}
The \textbf{ServerContext} class wraps the \textbf{CPUState}, \textbf{PipelineController}, and \textbf{Clock} instances to maintain a single source of information during the simulation. It can be said that the core of the simulator is kept here.

\subsection*{API Endpoints}
\label{subsec:api_endpoints}
The API exposes five main endpoints, each taken care of by a handler class— \textbf{LoadHandler}, \textbf{StepHandler}, \textbf{StateHandler}, \textbf{ResetHandler}, \textbf{HealthHandler}:

\begin{enumerate}
    \item \textbf{POST /api/load} --- Loads a program into instruction memory
    \begin{itemize}
        \item Query parameter: \texttt{start} (default: 0) --- Starting address for program loading
        \item Request body: Newline-separated MIPS assembly code instructions
        \item Response: JSON containing loaded count, start address, and end address
    \end{itemize}

    \item \textbf{POST /api/step} --- Advances simulation by specified number of cycles
    \begin{itemize}
        \item Query parameter: \texttt{cycles} (default: 1) --- Number of clock cycles to execute
        \item Response: JSON confirming number of cycles executed
    \end{itemize}

    \item \textbf{GET /api/state} --- Retrieves current CPU and pipeline state
    \begin{itemize}
        \item Response: JSON representation of registers, program counter, and pipeline registers
    \end{itemize}

    \item \textbf{POST /api/reset} --- Resets the simulator to initial state
    \begin{itemize}
        \item Query parameters:
        \begin{itemize}
            \item \texttt{clearRegs} --- Clear all registers (boolean)
            \item \texttt{clearMem} --- Clear data memory (boolean)
            \item \texttt{pc} --- Reset program counter to specified address (default: 0)
        \end{itemize}
        \item Response: JSON confirmation of reset operation
    \end{itemize}

    \item \textbf{GET /api/health} --- Health check endpoint for monitoring
    \begin{itemize}
        \item Response: Simple \texttt{"ok"} string
    \end{itemize}
\end{enumerate}

\subsection*{Cross-Origin Resource Sharing (CORS)}

The API server implements CORS headers to allow web-based frontends running on different origins to communicate with the simulator. All endpoints include the following headers:

\begin{itemize}
    \item \texttt{Access-Control-Allow-Origin: *}
    \item \texttt{Access-Control-Allow-Methods: GET, POST, OPTIONS}
    \item \texttt{Access-Control-Allow-Headers: Content-Type}
\end{itemize}

This enables the frontend application, hosted separately from the backend to make API requests without browser security restrictions. 

\subsection*{State Serialization}

The \textbf{StateSerializer} class converts the internal CPU and pipeline state into JSON format for transmission to the frontend. This serialization process:

\begin{itemize}
    \item Extracts program counter value
    \item Serializes all 32 registers into a JSON array
    \item Serializes pipeline register contents (IF/ID, ID/EX, EX/MEM, MEM/WB)
    \item Formats the data as a structured JSON object
\end{itemize}

\begin{lstlisting}[style=javaStyle]
public static String serialize(CPUState state, PipelineController controller) {
    StringBuilder sb = new StringBuilder();
    sb.append("{");
    sb.append("\"pc\":").append(state.pc.get()).append(',');
    sb.append("\"registers\":").append(serializeRegisters(state)).append(',');
    sb.append("\"pipeline\":").append(serializePipeline(controller)).append(',');
    sb.append("\"dataMemory\":").append(serializeDataMemory(state));
    sb.append(",\"pipelineHistory\":").append(serializeHistory(controller));
    sb.append("}");
    return sb.toString();
}
\end{lstlisting}

The serialized state enables the frontend to:
\begin{itemize}
    \item Display current register values
    \item Visualize instructions in each pipeline stage
    \item Track program execution progress
    \item Highlight data dependencies and hazards
\end{itemize}

\subsection*{Error Handling}

The API implements robust error handling:
\begin{itemize}
    \item Invalid HTTP methods return \texttt{405 Method Not Allowed}
    \item Malformed program data returns \texttt{400 Bad Request} with error details
    \item Invalid addresses or parameters are validated before processing
    \item Exceptions are caught and returned as JSON error responses
\end{itemize}

This design ensures that the frontend receives meaningful error messages and can handle any conditions that may arise during simulation.

\section{Frontend Implementation}

The frontend of the Simulator is implemented as a React web application which provides an interactive visualization interface for the simulation. Built with modern React patterns and Tailwind CSS, it offers real-time visualization of pipeline stages, register states, and memory contents.

\subsection{Application Architecture}

The application follows a component-based architecture centered around the main \texttt{App.js} component, which manages global state including CPU state, execution history, and user interface preferences. 

State management utilizes React hooks to maintain synchronization with the Java API in the backend through the RESTful endpoints described in Section~\ref{subsec:api_endpoints}.

The interface supports both predefined sample programs and custom user code with proper validation and error handling.

\subsection{Visualization Components}

\subsubsection{Pipeline Visualization System}

The application provides three distinct pipeline visualization modes:
\begin{itemize}
    \item \textbf{Detailed Pipeline View:} a vertical stack of all five stages with instruction information, such as including hex codes, program counters, and destination registers;
    \item \textbf{Pipeline Diagram View:} horizontal representation with color-coded stages and integrated data path visualization, showing real-time component activity including pipeline registers components, register file operations, ALU computations, and memory access patterns; 
    \item \textbf{Pipeline Gantt Chart:} provides temporal analysis through a cycle-by-cycle tabular display that tracks instruction progression and visually identifies pipeline hazards through color-coded states, including stalls, bubbles, and flushes.
\end{itemize}

\subsubsection{Data Display Components}

The \textbf{Register Grid} displays all 32 MIPS registers with dual decimal and hexadecimal representation, featuring hover tooltips that explain each register's architectural purpose and visual highlighting for active registers. 

The \textbf{Memory Grid} shows data memory contents with proper address-value mapping and hexadecimal formatting, providing insight into memory access patterns during program execution. 

Supporting components include the \texttt{Card} container for consistent UI styling, \texttt{EmptyState} placeholders for initialization states, and the \texttt{Constants.js} configuration file, which centralizes sample programs, stage descriptions, and register documentation.

\subsection{Simulation Control Panel}

The control panel handles simulation management through a toolbar interface. It features step execution controls for both single-cycle and multi-cycle advancement, a run/pause toggle for continuous execution, a reset function for re-initializing the simulator state, and a clock frequency control slider. The program loader toggle enables dynamic switching between sample programs and custom code input, while the real-time display shows the current program counter value with dual decimal and hexadecimal representation. 

\chapter{Testing and Validation}
\label{sec:testing}

The MIPS pipeline simulator is validated through a series of unit tests covering all major components and pipeline scenarios. The testing strategy employs systematic verification of individual components followed by integration testing of the complete pipeline.

\section{Test Execution Environment}
\begin{itemize}
    \item Framework: JUnit 5.10.2
    \item Java Version: OpenJDK 23.0.1
    \item IDE: IntelliJ IDEA 2024.2.3
    \item Build Tool: Maven
\end{itemize}

\section{Unit Tests - Component Validation}
\label{sec:unit-tests}

Before integration testing, each component is validated in isolation. The following tables summarize the unit tests for each major simulator component.

\subsection{Register File Unit Tests}

\begin{table}[H]
\centering
\caption{RegisterFileTest Results}
\label{tab:register-file-tests}
\small
\begin{tabular}{|l|l|c|c|c|}
\hline
\textbf{Test Method} & \textbf{Operation} & \textbf{Expected} & \textbf{Actual} & \textbf{Pass} \\
\hline
testSetAndGetRegister & set(5, 123); get(5) & 123 & 123 & \checkmark \\
testZeroRegisterAlwaysZero & set(0, 999); get(0) & 0 & 0 & \checkmark \\
testOverwriteRegister & set(10, 55); set(10, 99) & 99 & 99 & \checkmark \\
testAllRegistersInitiallyZero & get(0..31) & All 0 & All 0 & \checkmark \\
testSettingZeroRegister & set(0, 999); get(1) & 100, 0 & 100, 0 & \checkmark \\
\hline
\end{tabular}
\end{table}

\subsection{Data Memory Unit Tests}
\begin{table}[H]
\centering
\caption{DataMemoryTest Results}
\label{tab:data-memory-tests}
\small
\begin{tabular}{|l|l|c|c|c|}
\hline
\textbf{Test Method} & \textbf{Operation} & \textbf{Expected} & \textbf{Actual} & \textbf{Pass} \\
\hline
testStoreAndLoadWord & store(0, 12345); load(0) & 12345 & 12345 & \checkmark \\
testMultipleAddresses & store(0,10); store(4,20) & 10, 20, 30 & 10, 20, 30 & \checkmark \\
testLoadOutOfRange & load(-4); load(5000) & 0, 0 & 0, 0 & \checkmark \\
testStoreOutOfRange & store(-4, 999) & No exception & No exception & \checkmark \\
testWordAlignment & store(8, 123); load(8) & 123 & 123 & \checkmark \\
testSizeBytes & memory.sizeBytes() & 4096 & 4096 & \checkmark \\
testDefaultValues & load(0); load(100) & 0 & 0 & \checkmark \\
\hline
\end{tabular}
\end{table}

\subsection{Instruction Memory Unit Tests}
\begin{table}[H]
\centering
\caption{InstructionMemoryTest Results}
\label{tab:instr-memory-tests}
\small
\begin{tabular}{|l|l|c|c|c|}
\hline
\textbf{Test Method} & \textbf{Operation} & \textbf{Expected} & \textbf{Actual} & \textbf{Pass} \\
\hline
testFetchRType & set(0, R-type); fetch(0) & opcode=0 & opcode=0 & \checkmark \\
testFetchIType & set(4, I-type); fetch(4) & opcode=8 & opcode=8 & \checkmark \\
testFetchJType & set(8, J-type); fetch(8) & opcode=2 & opcode=2 & \checkmark \\
testFetchInvalidHigh & fetch(5000) & null & null & \checkmark \\
testFetchInvalidNegative & fetch(-4) & null & null & \checkmark \\
testWordAlignment & set(4, R); set(8, I) & Correct & Correct & \checkmark \\
testConstructorArray & new InstrMem(arr) & arr correct & arr correct & \checkmark \\
\hline
\end{tabular}
\end{table}

\subsection{Control Unit Tests}
\begin{table}[H]
\centering
\caption{ControlUnitTest Results - Control Signal Generation (All Tests Pass \checkmark)}
\label{tab:control-unit-tests}
\footnotesize
\begin{tabular}{|l|c|c|c|c|c|c|c|c|}
\hline
\textbf{Opcode} & \textbf{RegW} & \textbf{RegDst} & \textbf{ALUSrc} & \textbf{MemR} & \textbf{MemW} & \textbf{Branch} & \textbf{Jump} & \textbf{ALUOp} \\
\hline
R-type (0x00) & \checkmark & \checkmark & - & - & - & - & - & 2 \\
lw (0x23) & \checkmark & - & \checkmark & \checkmark & - & - & - & 0 \\
sw (0x2B) & - & - & \checkmark & - & \checkmark & - & - & 0 \\
beq (0x04) & - & - & - & - & - & \checkmark & - & 1 \\
bne (0x05) & - & - & - & - & - & \checkmark & - & 1 \\
addi (0x08) & \checkmark & - & \checkmark & - & - & - & - & 0 \\
ori (0x0D) & \checkmark & - & \checkmark & - & - & - & - & 3 \\
andi (0x0C) & \checkmark & - & \checkmark & - & - & - & - & 4 \\
slti (0x0A) & \checkmark & - & \checkmark & - & - & - & - & 5 \\
j (0x02) & - & - & - & - & - & - & \checkmark & - \\
jal (0x03) & \checkmark & - & - & - & - & - & \checkmark & - \\
Unknown & - & - & - & - & - & - & - & 0 \\
\hline
\end{tabular}
\end{table}

\subsection{Forwarding Unit Tests}
\begin{table}[H]
\centering
\caption{ForwardingUnitTest Results}
\label{tab:forwarding-unit-tests}
\small
\begin{tabular}{|l|l|c|c|c|}
\hline
\textbf{Test Method} & \textbf{Scenario} & \textbf{Expected} & \textbf{Actual} & \textbf{Pass} \\
\hline
testForwardFromEXMEM & ID/EX uses \$2, EX/MEM writes \$2 & fwdA=2 & fwdA=2 & \checkmark \\
testForwardFromMEMWB & ID/EX uses \$6, MEM/WB writes \$6 & fwdB=1 & fwdB=1 & \checkmark \\
testNoForwardingNeeded & No dependencies & fwdA=0, B=0 & fwdA=0, B=0 & \checkmark \\
\hline
\end{tabular}
\end{table}


\subsection{Hazard Detection Unit Tests}
\begin{table}[H]
\centering
\caption{HazardDetectionUnitTest Results}
\label{tab:hazard-detection-tests}
\small
\begin{tabular}{|l|l|c|c|c|}
\hline
\textbf{Test Method} & \textbf{Scenario} & \textbf{Expected} & \textbf{Actual} & \textbf{Pass} \\
\hline
testNoHazardsPipelineEmpty & Empty pipeline & No hazard & No hazard & \checkmark \\
testLoadUseHazard & lw \$t0; add uses \$t0 & Detected & Detected & \checkmark \\
testDataHazardFromEX & add \$t0; sub uses \$t0 & Detected & Detected & \checkmark \\
testDataHazardFromMEM & or \$t1; addi uses \$t1 & Detected & Detected & \checkmark \\
testControlHazardBranch & Branch taken in EX/MEM & Detected & Detected & \checkmark \\
testControlHazardJump & Jump in IF/ID & Detected & Detected & \checkmark \\
testStructuralHazard & EX/MEM, MEM/WB same reg & Detected & Detected & \checkmark \\
testNoHazardDiffRegs & Different src/dest regs & No hazard & No hazard & \checkmark \\
testZeroRegisterNoHazard & Write to \$zero & No hazard & No hazard & \checkmark \\
testLoadUseIType & lw; addi uses loaded & Detected & Detected & \checkmark \\
testZeroRegHazardIgnored & EX/MEM writes \$zero & No hazard & No hazard & \checkmark \\
testNoHazardIDEmpty & ID stage empty & No hazard & No hazard & \checkmark \\
\hline
\end{tabular}
\end{table}

\subsection{Stall Unit Tests}
\begin{table}[H]
\centering
\caption{StallUnitTest Results}
\label{tab:stall-unit-tests}
\small
\begin{tabular}{|l|l|c|c|c|}
\hline
\textbf{Test Method} & \textbf{Scenario} & \textbf{Expected} & \textbf{Actual} & \textbf{Pass} \\
\hline
testDetectsLoadUseHazard & lw \$2; add uses \$2 & stall=true & stall=true & \checkmark \\
testNoStallWhenNoHazard & Independent instructions & stall=false & stall=false & \checkmark \\
testControlSignalsReset & Hazard then no hazard & Signals reset & Signals reset & \checkmark \\
\hline
\end{tabular}
\end{table}

\subsection{Clock Unit Tests}
\begin{table}[H]
\centering
\caption{ClockTest Results}
\label{tab:clock-tests}
\small
\begin{tabular}{|l|l|c|c|c|}
\hline
\textbf{Test Method} & \textbf{Operation} & \textbf{Expected} & \textbf{Actual} & \textbf{Pass} \\
\hline
testTickIncrementsCycle & tick() & cycle=1 & cycle=1 & \checkmark \\
testRunMultipleCycles & run(5) & cycle=5 & cycle=5 & \checkmark \\
\hline
\end{tabular}
\end{table}

\subsection{Unit Test Summary}
\begin{table}[H]
\centering
\caption{Unit Test Results by Component}
\label{tab:unit-test-summary}
\begin{tabular}{|l|c|c|c|}
\hline
\textbf{Component} & \textbf{Test Count} & \textbf{Passed} & \textbf{Status} \\
\hline
RegisterFile & 5 & 5 & \textcolor{green}{\textbf{PASS}} \\
DataMemory & 7 & 7 & \textcolor{green}{\textbf{PASS}} \\
InstructionMemory & 7 & 7 & \textcolor{green}{\textbf{PASS}} \\
ControlUnit & 17 & 17 & \textcolor{green}{\textbf{PASS}} \\
ForwardingUnit & 3 & 3 & \textcolor{green}{\textbf{PASS}} \\
HazardDetectionUnit & 12 & 12 & \textcolor{green}{\textbf{PASS}} \\
StallUnit & 3 & 3 & \textcolor{green}{\textbf{PASS}} \\
Clock & 2 & 2 & \textcolor{green}{\textbf{PASS}} \\
Assembler & 20 & 20 & \textcolor{green}{\textbf{PASS}} \\
\hline
\textbf{Total Unit Tests} & \textbf{76} & \textbf{76} & \textcolor{green}{\textbf{100\%}} \\
\hline
\end{tabular}
\end{table}

\section{Integration Tests - Pipeline Validation}
\label{sec:integration-tests}

The integration tests validate the complete pipeline behavior using assembly programs that exercise multiple components simultaneously. The following tables present detailed test results organized by functional category.

\subsection{Arithmetic Operations Tests}

\begin{table}[H]
\centering
\caption{Test 1: Basic Arithmetic Operations}
\label{tab:test1}
\small
\begin{tabular}{|p{5.5cm}|p{3cm}|p{3cm}|}
\hline
\textbf{Assembly Code} & \textbf{Expected} & \textbf{Actual} \\
\hline
\texttt{addi \$t0, \$zero, 10} & \$t0 = 10 & \$t0 = 10 \\
\texttt{addi \$t1, \$zero, 5} & \$t1 = 5 & \$t1 = 5 \\
\texttt{add \$t0, \$t0, \$t1} & \$t0 = 15 & \$t0 = 15 \\
\texttt{sub \$t1, \$t0, \$t0} & \$t1 = 0 & \$t1 = 0 \\
\hline
\multicolumn{3}{|r|}{\textbf{Result: \textcolor{green}{PASS} \checkmark}} \\
\hline
\end{tabular}
\end{table}

\begin{table}[H]
\centering
\caption{Test 11: Negative Number Arithmetic}
\label{tab:test11}
\small
\begin{tabular}{|p{5.5cm}|p{3cm}|p{3cm}|}
\hline
\textbf{Assembly Code} & \textbf{Expected} & \textbf{Actual} \\
\hline
\texttt{addi \$t0, \$zero, -1} & \$t0 = -1 & \$t0 = -1 \\
\texttt{addi \$t1, \$zero, -10} & \$t1 = -10 & \$t1 = -10 \\
\texttt{add \$t2, \$t0, \$t1} & \$t2 = -11 & \$t2 = -11 \\
\hline
\multicolumn{3}{|r|}{\textbf{Result: \textcolor{green}{PASS} \checkmark}} \\
\hline
\end{tabular}
\end{table}

\begin{table}[H]
\centering
\caption{Test 12: Overflow Behavior}
\label{tab:test12}
\small
\begin{tabular}{|p{5.5cm}|p{3cm}|p{3cm}|}
\hline
\textbf{Assembly Code} & \textbf{Expected} & \textbf{Actual} \\
\hline
\texttt{addi \$t0, \$zero, 32767} & \$t0 = 32767 & \$t0 = 32767 \\
\texttt{addi \$t0, \$t0, 32767} & \$t0 = 65534 & \$t0 = 65534 \\
\texttt{addi \$t0, \$t0, 2} & \$t0 = 65536 & \$t0 = 65536 \\
\hline
\multicolumn{3}{|r|}{\textbf{Result: \textcolor{green}{PASS} \checkmark}} \\
\hline
\end{tabular}
\end{table}

\subsection{Logical Operations Tests}

\begin{table}[H]
\centering
\caption{Test 8: Bitwise Logical Operations}
\label{tab:test8}
\small
\begin{tabular}{|p{5.5cm}|p{3cm}|p{3cm}|}
\hline
\textbf{Assembly Code} & \textbf{Expected} & \textbf{Actual} \\
\hline
\texttt{addi \$t0, \$zero, 15} & \$t0 = 0x0F & \$t0 = 0x0F \\
\texttt{addi \$t1, \$zero, 240} & \$t1 = 0xF0 & \$t1 = 0xF0 \\
\texttt{and \$t2, \$t0, \$t1} & \$t2 = 0 & \$t2 = 0 \\
\texttt{or \$t3, \$t0, \$t1} & \$t3 = 255 & \$t3 = 255 \\
\texttt{xor \$t4, \$t0, \$t0} & \$t4 = 0 & \$t4 = 0 \\
\texttt{nor \$t5, \$zero, \$zero} & \$t5 = -1 & \$t5 = -1 \\
\hline
\multicolumn{3}{|r|}{\textbf{Result: \textcolor{green}{PASS} \checkmark}} \\
\hline
\end{tabular}
\end{table}

\begin{table}[H]
\centering
\caption{Test 9: Set Less Than (SLT)}
\label{tab:test9}
\small
\begin{tabular}{|p{5.5cm}|p{3cm}|p{3cm}|}
\hline
\textbf{Assembly Code} & \textbf{Expected} & \textbf{Actual} \\
\hline
\texttt{addi \$t0, \$zero, 5} & \$t0 = 5 & \$t0 = 5 \\
\texttt{addi \$t1, \$zero, 10} & \$t1 = 10 & \$t1 = 10 \\
\texttt{slt \$t2, \$t0, \$t1} & \$t2 = 1 (5 < 10) & \$t2 = 1 \\
\texttt{slt \$t3, \$t1, \$t0} & \$t3 = 0 (10 < 5) & \$t3 = 0 \\
\hline
\multicolumn{3}{|r|}{\textbf{Result: \textcolor{green}{PASS} \checkmark}} \\
\hline
\end{tabular}
\end{table}

\begin{table}[H]
\centering
\caption{Test 24: Immediate Logical Operations}
\label{tab:test24}
\small
\begin{tabular}{|p{5.5cm}|p{3cm}|p{3cm}|}
\hline
\textbf{Assembly Code} & \textbf{Expected} & \textbf{Actual} \\
\hline
\texttt{addi \$t0, \$zero, 0xFF} & \$t0 = 255 & \$t0 = 255 \\
\texttt{ori \$t1, \$t0, 0x0F0} & \$t1 = 255 & \$t1 = 255 \\
\texttt{andi \$t2, \$t0, 0x0F} & \$t2 = 15 & \$t2 = 15 \\
\texttt{slti \$t4, \$t3, 20} & \$t4 = 1 (10<20) & \$t4 = 1 \\
\texttt{slti \$t5, \$t3, 5} & \$t5 = 0 (10<5) & \$t5 = 0 \\
\hline
\multicolumn{3}{|r|}{\textbf{Result: \textcolor{green}{PASS} \checkmark}} \\
\hline
\end{tabular}
\end{table}

\subsection{Shift Operations Tests}

\begin{table}[H]
\centering
\caption{Test 21: Shift Left Logical (SLL)}
\label{tab:test21}
\small
\begin{tabular}{|p{5.5cm}|p{3cm}|p{3cm}|}
\hline
\textbf{Assembly Code} & \textbf{Expected} & \textbf{Actual} \\
\hline
\texttt{addi \$t0, \$zero, 1} & \$t0 = 1 & \$t0 = 1 \\
\texttt{sll \$t1, \$t0, 3} & \$t1 = 8 & \$t1 = 8 \\
\texttt{sll \$t2, \$t0, 0} & \$t2 = 1 & \$t2 = 1 \\
\texttt{addi \$t3, \$zero, -1} & \$t3 = 0xFFFFFFFF & \$t3 = 0xFFFFFFFF \\
\texttt{sll \$t4, \$t3, 16} & \$t4 = 0xFFFF0000 & \$t4 = 0xFFFF0000 \\
\hline
\multicolumn{3}{|r|}{\textbf{Result: \textcolor{green}{PASS} \checkmark}} \\
\hline
\end{tabular}
\end{table}

\begin{table}[H]
\centering
\caption{Test 22: Shift Right Logical (SRL)}
\label{tab:test22}
\small
\begin{tabular}{|p{5.5cm}|p{3cm}|p{3cm}|}
\hline
\textbf{Assembly Code} & \textbf{Expected} & \textbf{Actual} \\
\hline
\texttt{addi \$t0, \$zero, 8} & \$t0 = 8 & \$t0 = 8 \\
\texttt{srl \$t1, \$t0, 3} & \$t1 = 1 & \$t1 = 1 \\
\texttt{addi \$t2, \$zero, -1} & \$t2 = 0xFFFFFFFF & \$t2 = 0xFFFFFFFF \\
\texttt{srl \$t3, \$t2, 16} & \$t3 = 0x0000FFFF & \$t3 = 0x0000FFFF \\
\hline
\multicolumn{3}{|r|}{\textbf{Result: \textcolor{green}{PASS} \checkmark}} \\
\hline
\end{tabular}
\end{table}

\subsection{Memory Operations Tests}

\begin{table}[H]
\centering
\caption{Test 4: Basic Load/Store Operations}
\label{tab:test4}
\small
\begin{tabular}{|p{5.5cm}|p{3cm}|p{3cm}|}
\hline
\textbf{Assembly Code} & \textbf{Expected} & \textbf{Actual} \\
\hline
\texttt{addi \$t0, \$zero, 100} & \$t0 = 100 & \$t0 = 100 \\
\texttt{addi \$t1, \$zero, 200} & \$t1 = 200 & \$t1 = 200 \\
\texttt{sw \$t0, 0(\$zero)} & Mem[0] = 100 & Mem[0] = 100 \\
\texttt{sw \$t1, 4(\$zero)} & Mem[4] = 200 & Mem[4] = 200 \\
\texttt{lw \$t2, 0(\$zero)} & \$t2 = 100 & \$t2 = 100 \\
\texttt{lw \$t3, 4(\$zero)} & \$t3 = 200 & \$t3 = 200 \\
\hline
\multicolumn{3}{|r|}{\textbf{Result: \textcolor{green}{PASS} \checkmark}} \\
\hline
\end{tabular}
\end{table}

\begin{table}[H]
\centering
\caption{Test 13: Sequential Memory Access}
\label{tab:test13}
\small
\begin{tabular}{|p{5.5cm}|p{3cm}|p{3cm}|}
\hline
\textbf{Assembly Code} & \textbf{Expected} & \textbf{Actual} \\
\hline
\texttt{sw \$t0, 0(\$zero)} & Mem[0] = 10 & Mem[0] = 10 \\
\texttt{sw \$t1, 4(\$zero)} & Mem[4] = 20 & Mem[4] = 20 \\
\texttt{sw \$t2, 8(\$zero)} & Mem[8] = 30 & Mem[8] = 30 \\
\texttt{sw \$t3, 12(\$zero)} & Mem[12] = 40 & Mem[12] = 40 \\
\texttt{sw \$t4, 16(\$zero)} & Mem[16] = 50 & Mem[16] = 50 \\
\hline
\multicolumn{3}{|r|}{\textbf{Result: \textcolor{green}{PASS} \checkmark}} \\
\hline
\end{tabular}
\end{table}

\begin{table}[H]
\centering
\caption{Test 16: Offset Addressing with Negative Offsets}
\label{tab:test16}
\small
\begin{tabular}{|p{5.5cm}|p{3cm}|p{3cm}|}
\hline
\textbf{Assembly Code} & \textbf{Expected} & \textbf{Actual} \\
\hline
\texttt{addi \$t0, \$zero, 100} & \$t0 = 100 & \$t0 = 100 \\
\texttt{addi \$t1, \$zero, 77} & \$t1 = 77 & \$t1 = 77 \\
\texttt{sw \$t1, 0(\$t0)} & Mem[100] = 77 & Mem[100] = 77 \\
\texttt{sw \$t1, 4(\$t0)} & Mem[104] = 77 & Mem[104] = 77 \\
\texttt{sw \$t1, -4(\$t0)} & Mem[96] = 77 & Mem[96] = 77 \\
\hline
\multicolumn{3}{|r|}{\textbf{Result: \textcolor{green}{PASS} \checkmark}} \\
\hline
\end{tabular}
\end{table}

\begin{table}[H]
\centering
\caption{Test 29: Memory Sign Extension and Edge Cases}
\label{tab:test29}
\small
\begin{tabular}{|p{5.5cm}|p{3cm}|p{3cm}|}
\hline
\textbf{Assembly Code} & \textbf{Expected} & \textbf{Actual} \\
\hline
\texttt{addi \$t0, \$zero, 0xBEEF} & 0xFFFFBEEF & 0xFFFFBEEF \\
\texttt{sw \$t0, 0(\$zero)} & Mem[0]=0xFFFFBEEF & Mem[0]=0xFFFFBEEF \\
\texttt{lw \$t1, 0(\$zero)} & 0xFFFFBEEF & 0xFFFFBEEF \\
\texttt{sw \$t3, 100(\$zero)} & Mem[100] = 2 & Mem[100] = 2 \\
\texttt{lw \$t4, 100(\$zero)} & \$t4 = 2 & \$t4 = 2 \\
\hline
\multicolumn{3}{|r|}{\textbf{Result: \textcolor{green}{PASS} \checkmark}} \\
\hline
\end{tabular}
\end{table}

\subsection{Control Flow Tests}

\begin{table}[H]
\centering
\caption{Test 5: Branch Equal (Taken)}
\label{tab:test5}
\small
\begin{tabular}{|p{5.5cm}|p{3cm}|p{3cm}|}
\hline
\textbf{Assembly Code} & \textbf{Expected} & \textbf{Actual} \\
\hline
\texttt{addi \$t0, \$zero, 5} & \$t0 = 5 & \$t0 = 5 \\
\texttt{addi \$t1, \$zero, 5} & \$t1 = 5 & \$t1 = 5 \\
\texttt{beq \$t0, \$t1, target} & Branch taken & Branch taken \\
\texttt{addi \$t0, \$zero, 88} & Skipped & Skipped \\
\texttt{target: addi \$t0, \$zero, 99} & \$t0 = 99 & \$t0 = 99 \\
\hline
\multicolumn{3}{|r|}{\textbf{Result: \textcolor{green}{PASS} \checkmark}} \\
\hline
\end{tabular}
\end{table}

\begin{table}[H]
\centering
\caption{Test 6: Branch Equal (Not Taken)}
\label{tab:test6}
\small
\begin{tabular}{|p{5.5cm}|p{3cm}|p{3cm}|}
\hline
\textbf{Assembly Code} & \textbf{Expected} & \textbf{Actual} \\
\hline
\texttt{addi \$t0, \$zero, 5} & \$t0 = 5 & \$t0 = 5 \\
\texttt{addi \$t1, \$zero, 6} & \$t1 = 6 & \$t1 = 6 \\
\texttt{beq \$t0, \$t1, target} & Not taken & Not taken \\
\texttt{addi \$t2, \$zero, 77} & \$t2 = 77 & \$t2 = 77 \\
\texttt{target: addi \$t2, \$zero, 88} & \$t2 = 88 & \$t2 = 88 \\
\hline
\multicolumn{3}{|r|}{\textbf{Result: \textcolor{green}{PASS} \checkmark}} \\
\hline
\end{tabular}
\end{table}

\begin{table}[H]
\centering
\caption{Test 7: Branch Not Equal}
\label{tab:test7}
\small
\begin{tabular}{|p{5.5cm}|p{3cm}|p{3cm}|}
\hline
\textbf{Assembly Code} & \textbf{Expected} & \textbf{Actual} \\
\hline
\texttt{addi \$t0, \$zero, 5} & \$t0 = 5 & \$t0 = 5 \\
\texttt{addi \$t1, \$zero, 6} & \$t1 = 6 & \$t1 = 6 \\
\texttt{bne \$t0, \$t1, target} & Taken (5$\neq$6) & Taken \\
\texttt{addi \$t3, \$zero, 99} & Skipped & Skipped \\
\texttt{target: addi \$t3, \$zero, 111} & \$t3 = 111 & \$t3 = 111 \\
\hline
\multicolumn{3}{|r|}{\textbf{Result: \textcolor{green}{PASS} \checkmark}} \\
\hline
\end{tabular}
\end{table}

\begin{table}[H]
\centering
\caption{Test 23: Jump and Link (JAL)}
\label{tab:test23}
\small
\begin{tabular}{|p{5.5cm}|p{3cm}|p{3cm}|}
\hline
\textbf{Assembly Code} & \textbf{Expected} & \textbf{Actual} \\
\hline
\texttt{jal function} & \$ra = 0x4 & \$ra = 0x4 \\
\texttt{j end} & Jump to end & Jump executed \\
\texttt{function: addi \$t1, \$zero, 42} & \$t1 = 42 & \$t1 = 42 \\
\texttt{j end} & Return to end & Return executed \\
\texttt{end: addi \$t2, \$zero, 77} & \$t2 = 77 & \$t2 = 77 \\
\hline
\multicolumn{3}{|r|}{\textbf{Result: \textcolor{green}{PASS} \checkmark}} \\
\hline
\end{tabular}
\end{table}

\begin{table}[H]
\centering
\caption{Test 14: Loop Counter Implementation}
\label{tab:test14}
\small
\begin{tabular}{|p{5.5cm}|p{3cm}|p{3cm}|}
\hline
\textbf{Assembly Code} & \textbf{Expected} & \textbf{Actual} \\
\hline
\texttt{addi \$t0, \$zero, 0} & counter = 0 & counter = 0 \\
\texttt{addi \$t1, \$zero, 5} & limit = 5 & limit = 5 \\
\texttt{loop: addi \$t0, \$t0, 1} & counter++ & Increments \\
\texttt{slt \$t2, \$t0, \$t1} & compare & compare \\
\texttt{bne \$t2, \$zero, loop} & Loop 5× & Loop 5× \\
\textbf{Final Result} & \$t0 = 5 & \$t0 = 5 \\
\hline
\multicolumn{3}{|r|}{\textbf{Result: \textcolor{green}{PASS} \checkmark}} \\
\hline
\end{tabular}
\end{table}

\subsection{Data Hazard Tests}
\begin{table}[H]
\centering
\caption{Test 2: RAW Data Hazard with Forwarding}
\label{tab:test2}
\small
\begin{tabular}{|p{5.5cm}|p{3cm}|p{3cm}|}
\hline
\textbf{Assembly Code} & \textbf{Expected} & \textbf{Actual} \\
\hline
\texttt{addi \$t1, \$zero, 10} & \$t1 = 10 & \$t1 = 10 \\
\texttt{addi \$t2, \$zero, 10} & \$t2 = 10 & \$t2 = 10 \\
\texttt{add \$t0, \$t1, \$t2} & \$t0 = 20 & \$t0 = 20 \\
\texttt{add \$t3, \$t0, \$zero} & \$t3 = 20 (RAW) & \$t3 = 20 \\
\hline
\multicolumn{3}{|p{12cm}|}{\textit{Hazard: \$t0 used immediately after write - resolved via EX/MEM forwarding}} \\
\hline
\multicolumn{3}{|r|}{\textbf{Result: \textcolor{green}{PASS} \checkmark}} \\
\hline
\end{tabular}
\end{table}

\begin{table}[H]
\centering
\caption{Test 3: Load-Use Hazard with Stall}
\label{tab:test3}
\small
\begin{tabular}{|p{5.5cm}|p{3cm}|p{3cm}|}
\hline
\textbf{Assembly Code} & \textbf{Expected} & \textbf{Actual} \\
\hline
\texttt{addi \$t0, \$zero, 42} & \$t0 = 42 & \$t0 = 42 \\
\texttt{sw \$t0, 0(\$zero)} & Mem[0] = 42 & Mem[0] = 42 \\
\texttt{lw \$t1, 0(\$zero)} & \$t1 = 42 & \$t1 = 42 \\
\texttt{add \$t2, \$t1, \$zero} & \$t2 = 42 & \$t2 = 42 \\
\hline
\multicolumn{3}{|p{12cm}|}{\textit{Hazard: Load-use requires 1-cycle stall before forwarding}} \\
\hline
\multicolumn{3}{|r|}{\textbf{Result: \textcolor{green}{PASS} \checkmark}} \\
\hline
\end{tabular}
\end{table}

\begin{table}[H]
\centering
\caption{Test 17: Multiple Consecutive RAW Hazards}
\label{tab:test17}
\small
\begin{tabular}{|p{5.5cm}|p{3cm}|p{3cm}|}
\hline
\textbf{Assembly Code} & \textbf{Expected} & \textbf{Actual} \\
\hline
\texttt{addi \$t0, \$zero, 10} & \$t0 = 10 & \$t0 = 10 \\
\texttt{add \$t1, \$t0, \$t0} & \$t1 = 20 & \$t1 = 20 \\
\texttt{add \$t2, \$t1, \$t1} & \$t2 = 40 & \$t2 = 40 \\
\texttt{add \$t3, \$t2, \$t2} & \$t3 = 80 & \$t3 = 80 \\
\hline
\multicolumn{3}{|p{12cm}|}{\textit{Chain: each instruction depends on previous - all resolved via forwarding}} \\
\hline
\multicolumn{3}{|r|}{\textbf{Result: \textcolor{green}{PASS} \checkmark}} \\
\hline
\end{tabular}
\end{table}

\begin{table}[H]
\centering
\caption{Test 26: Complex Pipeline Hazard Chains}
\label{tab:test26}
\small
\begin{tabular}{|p{5.5cm}|p{3cm}|p{3cm}|}
\hline
\textbf{Assembly Code} & \textbf{Expected} & \textbf{Actual} \\
\hline
\texttt{addi \$t0, \$zero, 1} & \$t0 = 1 & \$t0 = 1 \\
\texttt{add \$t1, \$t0, \$t0} & \$t1 = 2 & \$t1 = 2 \\
\texttt{add \$t2, \$t1, \$t1} & \$t2 = 4 & \$t2 = 4 \\
\texttt{add \$t3, \$t2, \$t2} & \$t3 = 8 & \$t3 = 8 \\
\texttt{add \$t4, \$t3, \$t3} & \$t4 = 16 & \$t4 = 16 \\
\texttt{add \$t7, \$t5, \$t6} & \$t7 = 5 & \$t7 = 5 \\
\texttt{sub \$t8, \$t7, \$t5} & \$t8 = 3 & \$t8 = 3 \\
\texttt{and \$t9, \$t8, \$t6} & \$t9 = 3 & \$t9 = 3 \\
\hline
\multicolumn{3}{|r|}{\textbf{Result: \textcolor{green}{PASS} \checkmark}} \\
\hline
\end{tabular}
\end{table}

\subsection{Special Cases and Edge Tests}
\begin{table}[H]
\centering
\caption{Test 10: Zero Register Immutability}
\label{tab:test10}
\small
\begin{tabular}{|p{5.5cm}|p{3cm}|p{3cm}|}
\hline
\textbf{Assembly Code} & \textbf{Expected} & \textbf{Actual} \\
\hline
\texttt{addi \$zero, \$zero, 100} & \$zero = 0 & \$zero = 0 \\
\texttt{add \$t0, \$zero, \$zero} & \$t0 = 0 & \$t0 = 0 \\
\hline
\multicolumn{3}{|p{12cm}|}{\textit{Hardware constraint: \$zero register is hardwired to 0}} \\
\hline
\multicolumn{3}{|r|}{\textbf{Result: \textcolor{green}{PASS} \checkmark}} \\
\hline
\end{tabular}
\end{table}

\begin{table}[H]
\centering
\caption{Test 15: Fibonacci Sequence Computation}
\label{tab:test15}
\small
\begin{tabular}{|p{5.5cm}|p{3cm}|p{3cm}|}
\hline
\textbf{Assembly Code} & \textbf{Expected} & \textbf{Actual} \\
\hline
\texttt{addi \$t0, \$zero, 0} & fib(0) = 0 & 0 \\
\texttt{addi \$t1, \$zero, 1} & fib(1) = 1 & 1 \\
\texttt{add \$t2, \$t0, \$t1} & fib(2) = 1 & 1 \\
\texttt{add \$t0, \$t1, \$t2} & fib(3) = 2 & 2 \\
\texttt{add \$t1, \$t2, \$t0} & fib(4) = 3 & 3 \\
\hline
\multicolumn{3}{|p{12cm}|}{\textit{Memory: Mem[100..116] = [0, 1, 1, 2, 3]}} \\
\hline
\multicolumn{3}{|r|}{\textbf{Result: \textcolor{green}{PASS} \checkmark}} \\
\hline
\end{tabular}
\end{table}

\begin{table}[H]
\centering
\caption{Test 20: Stress Test - Multiple Operations}
\label{tab:test20}
\small
\begin{tabular}{|p{5.5cm}|p{3cm}|p{3cm}|}
\hline
\textbf{Operation Sequence} & \textbf{Expected} & \textbf{Actual} \\
\hline
Initialize \$s0..\$s4 = 1..5 & Sequential init & Correct \\
\texttt{add \$s5, \$s0, \$s1} & \$s5 = 3 & \$s5 = 3 \\
\texttt{add \$s6, \$s2, \$s3} & \$s6 = 7 & \$s6 = 7 \\
\texttt{add \$s7, \$s4, \$s5} & \$s7 = 8 & \$s7 = 8 \\
\texttt{sub \$t0, \$s6, \$s7} & \$t0 = -1 & \$t0 = -1 \\
\texttt{and \$t1, \$s0, \$s1} & \$t1 = 0 & \$t1 = 0 \\
\texttt{or \$t2, \$s2, \$s3} & \$t2 = 7 & \$t2 = 7 \\
\texttt{xor \$t3, \$s4, \$s5} & \$t3 = 6 & \$t3 = 6 \\
\hline
\multicolumn{3}{|r|}{\textbf{Result: \textcolor{green}{PASS} \checkmark}} \\
\hline
\end{tabular}
\end{table}

\subsection{Integration Test Results Summary}

\begin{table}[H]
\centering
\caption{Integration Test Results by Category}
\label{tab:integration-test-summary}
\begin{tabular}{|l|c|c|c|}
\hline
\textbf{Test Category} & \textbf{Tests} & \textbf{Passed} & \textbf{Status} \\
\hline
Arithmetic Operations & 1, 11, 12 & 3/3 & \textcolor{green}{\textbf{PASS}} \\
Logical Operations & 8, 9, 24 & 3/3 & \textcolor{green}{\textbf{PASS}} \\
Shift Operations & 21, 22 & 2/2 & \textcolor{green}{\textbf{PASS}} \\
Memory Operations & 4, 13, 16, 25, 29 & 5/5 & \textcolor{green}{\textbf{PASS}} \\
Control Flow & 5, 6, 7, 14, 19, 23, 27 & 7/7 & \textcolor{green}{\textbf{PASS}} \\
Data Hazards & 2, 3, 17, 18, 26 & 5/5 & \textcolor{green}{\textbf{PASS}} \\
Special Cases & 10, 15, 20, 28 & 4/4 & \textcolor{green}{\textbf{PASS}} \\
\hline
\textbf{Total Integration Tests} & \textbf{29} & \textbf{29/29} & \textcolor{green}{\textbf{100\%}} \\
\hline
\end{tabular}
\end{table}

\subsection{Complete Test Suite Summary}

\begin{table}[H]
\centering
\caption{Total Test Coverage}
\label{tab:total-tests}
\begin{tabular}{|l|c|c|c|}
\hline
\textbf{Test Type} & \textbf{Count} & \textbf{Passed} & \textbf{Status} \\
\hline
Unit Tests (Component) & 76 & 76 & \textcolor{green}{\textbf{100\%}} \\
Integration Tests (Pipeline) & 29 & 29 & \textcolor{green}{\textbf{100\%}} \\
Assembler Tests & 20 & 20 & \textcolor{green}{\textbf{100\%}} \\
\hline
\textbf{Grand Total} & \textbf{125} & \textbf{125} & \textcolor{green}{\textbf{100\%}} \\
\hline
\end{tabular}
\end{table}

\section{Key Validation Points}
\label{sec:key-validation}

\subsection{Hazard Resolution Success}
The forwarding unit correctly handles all RAW hazards, as demonstrated in Tests 2, 17, and 26. Load-use hazards are properly managed with stalls (Test 3), and control hazards are resolved with correct branch prediction in the ID stage (Tests 5-7, 27).

\subsection{Memory System Integrity}
All memory operations maintain proper alignment (Test 25), with correct sign extension for load operations (Test 29). The data memory correctly handles sequential accesses (Test 13) and offset addressing (Test 16).

\subsection{Control Flow Accuracy}
Branch instructions (\texttt{beq}, \texttt{bne}) correctly evaluate conditions and redirect program flow (Tests 5-7, 19). Jump instructions (\texttt{j}, \texttt{jal}) properly update the program counter and save return addresses (Test 23).

\subsection{Arithmetic and Logical Correctness}
All ALU operations produce correct results, including edge cases for overflow (Test 12), negative numbers (Test 11), and logical operations with immediate values (Test 24).

\section{Performance Metrics}
\label{sec:performance-metrics}

\begin{itemize}
    \item \textbf{Test Coverage:} 100\% of implemented MIPS instruction subset
    \item \textbf{Success Rate:} all tests passed (100\%)
    \item \textbf{Hazard Detection:} 100\% accuracy in simulated scenarios
    \item \textbf{Forwarding Efficiency:} Correct forwarding in all applicable cases
\end{itemize}

\section{Conclusion}
\label{sec:testing-conclusion}

The test suite validates that the MIPS pipeline simulator correctly implements:
\begin{itemize}
    \item All supported arithmetic and logical operations
    \item Complete memory subsystem with proper alignment
    \item Full hazard detection and forwarding
    \item Accurate control flow handling
    \item Edge case behavior, including overflow and negative numbers
\end{itemize}

The 100\% pass rate across diverse test cases demonstrates the robustness and correctness of the implementation. Each component functions correctly in isolation and integrates properly within the pipeline, confirming that the design specifications are successfully met.

\printbibliography
\nocite{*}

\vspace{2cm}
\begin{center}
  Distributed systems (DS)\\
  \includegraphics[width=10cm]{fig/footer}
\end{center}



\end{document}