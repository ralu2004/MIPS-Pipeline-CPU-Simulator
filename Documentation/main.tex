\documentclass[a4paper,12pt]{report}

\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage[margin=2cm]{geometry}
\usepackage{listings}
\usepackage{color}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{tabularx}
\usepackage{rotating}
\usepackage{amsmath}
\usepackage{float}
\usepackage[backend=biber, style=numeric, sorting=ynt]{biblatex}
\usepackage{colortbl}
\definecolor{headerblue}{RGB}{79,129,189}
\usepackage{tikz}
\usepackage{pdflscape}
\usepackage{comment}
\usetikzlibrary{shapes, arrows, positioning}
%\usepackage{verbatim}
%\usepackage{mdframed}
%\usepackage{algorithmic}
%\usepackage[linesnumbered,ruled,vlined]{algorithm2e}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=black,
    citecolor=black,
    urlcolor=black,
    pdfborder={0 0 0} 
}

\bibliography{citations}

\lstdefinestyle{lstcustom}{
backgroundcolor=\color{backcolour},
commentstyle=\color{codegreen},
keywordstyle=\color{magenta},
numberstyle=\tiny\color{codegray},
stringstyle=\color{codepurple},
basicstyle=\ttfamily\footnotesize,
breakatwhitespace=false,
breaklines=true,
captionpos=b,
keepspaces=true,
numbers=left,
numbersep=5pt,
showspaces=false,
showstringspaces=false,
showtabs=false,
tabsize=2
}

\lstdefinestyle{javaStyle}{
  language=Java,
  basicstyle=\ttfamily\small,
  keywordstyle=\color{blue}\bfseries,
  commentstyle=\color{green!50!black}\itshape,
  stringstyle=\color{orange},
  numbers=left,
  numberstyle=\tiny\color{gray},
  stepnumber=1,
  numbersep=5pt,
  showstringspaces=false,
  tabsize=2,
  breaklines=true,
  frame=single
}

\lstset{style=lstcustom}
\setlength{\parindent}{0pt}

\begin{document}

\vspace{-5cm}
\begin{center}
    Department of Computer Science\\
    Technical University of Cluj-Napoca\\
    \includegraphics[width=10cm]{fig/footer}
    \end{center}
    \vspace{1cm}
    \begin{center}
    \begin{Large}
     \textbf{CPU Simulator}\\
    \end{Large}
    \textit{MIPS Pipeline Architecture}\\
    \vspace{3cm}
    Name:\ Raluca-Mihaela Adam\\
    Group:\ 30422\\
    Email:\ adam.ra.raluca@student.utcluj.ro\\
    \vspace{12cm}
    Teaching Assistant: Dragos Lazea\\
    \vspace{1cm}
    \includegraphics[width=10cm]{fig/footer}
\end{center}

\tableofcontents

\chapter{Introduction}\label{ch:arch}

\section{Context}
This project aims to develop an educational CPU simulation software that mimics the 5-stage MIPS (Microprocessor without Interlocked Pipeline Stages) pipeline based on the 32-bit MIPS Instruction Set Architecture (ISA).

The simulator will visualize the flow of instruction through the MIPS pipeline, detect and display hazards, and help users understand the dynamics of parallel execution inside a CPU through a graphical user interface.

\section{Problem and Motivation}

In traditional computer architecture courses, students often struggle to understand the functioning of the CPU pipeline and the types of hazards that arise during instruction execution. Existing tools, such as MARS and SPIM simulators, allow users to run MIPS assembly programs but do not provide an intuitive visualization of how instructions propagate through the pipeline.

This project addresses this educational gap by providing a visual simulation software that demonstrates how instructions overlap inside a pipeline, how hazards occur, and how forwarding or stalling mechanisms resolve them in an interactive and easy-to-follow manner.

\section{Objectives and Proposed Solution}

The proposed application will consist of:
\begin{itemize}
    \item An execution engine that simulates the MIPS instruction flow and pipeline stages.
    \item An intuitive graphical user interface for interactive visualization that allows users to either input custom instructions or select predefined programs.
    \item The possibility to simulate at least 15 MIPS instructions (R, I, and J types).
    \item Real-time visualization of the 5 pipeline stages (IF, ID, EX, MEM, WB).
    \item Display of registers, memory contents, ALU operations, and control flags.
\end{itemize}

\section{Project Timeline and Plan}

The development of the MIPS 32 Simulator will follow a structured timeline, as presented below:

\begin{itemize}
    \item \textbf{Meeting 2:}  
    Documentation phase — prepare the project introduction, bibliographic research, bibliography, and project plan. Establish the main objectives and overall development strategy.
    
    \item \textbf{Meeting 3:}  
    Analysis and \textbf{Design Phase 1} — describe the system architecture, main modules, and component interactions. Provide an initial view of the implementation.
    
    \item \textbf{Meeting 4:}  
    Updated design and \textbf{back-end implementation} — refine the architecture based on feedback and corrections. Begin coding the back-end, defining class structures, storage mechanisms, and pipeline simulation logic.
    
    \item \textbf{Meeting 5:}  
    Finalize the back-end implementation. Begin developing the \textbf{front-end} to visualize the pipeline stages and display simulation data in real time.
    
    \item \textbf{Meeting 6:}  
    \textbf{Testing and validation} — verify functionality through unit and integration tests.
    
    \item \textbf{Meeting 7:}  
    \textbf{Final demo and presentation} — deliver the complete simulator, full documentation, and the final presentation showcasing the system’s capabilities.
\end{itemize}


\chapter{Bibliographic Research}\label{ch:arch}
\section{Importance of CPU Pipelining}
The performance of a processor depends on factors such as clock speed, critical path length, and cycles per instruction (CPI). A single-cycle CPU executes one instruction per clock cycle, making the design simple but inefficient because not all instructions take the same amount of time. Pipelining addresses this limitation by allowing multiple instructions to be processed simultaneously at different stages. The pipeline architecture is designed for throughput, increasing CPU performance, but introduces hazards - structural, data, and control hazards - that must be detected and resolved for correctness.

\section{MIPS Architecture and Pipelining}
The MIPS Architecture is a reduced instruction set computer (RISC) design. Its pipeline implementation consists of 5 execution stages: Instruction Fetch, Instruction Decode, Execute, Memory, and Write Back, which enable the parallel processing of multiple instructions. 

In a software simulator, true parallel execution is not possible; however, an event-based software architecture can create the illusion of concurrency while preserving accuracy in time and hazard detection.

\section{Existing Tools}
Several existing MIPS simulators are available:
\begin{itemize}
    \item \textbf{MARS} \cite{mars} — A Java-based MIPS simulator commonly used in academia. It supports assembly code execution, but is limited by poor visualisation of the pipeline.
    \item \textbf{SPIM} \cite{spim} — One of the earliest MIPS simulators. It is focused mainly on instruction correctness rather than pipeline-level execution.
\end{itemize}

In \cite{cornell}, the authors present a comprehensive theoretical explanation of the MIPS pipeline and the types of hazards, but without an interactive or visual component. 
As a general observation, all of the existing solutions above suffer from a lack of visual representation. Thus, this project aims to provide a slightly different perspective by creating an interactive, educational simulator that focuses on how instructions move through the pipeline and how hazards affect performance.

\section{Software Design Considerations}
The simulator will follow object-oriented design principles such as modularity, encapsulation, and separation of concerns. The architecture will clearly separate:
\begin{itemize}
    \item the execution engine (responsible for instruction handling and pipeline state),
    \item the data model (registers, memory, instructions), and
    \item the user interface layer (for visualization and user interaction).
\end{itemize}


\chapter{Analysis}\label{ch:analysis}

This chapter presents the theoretical foundations for the MIPS CPU simulator, detailing the hardware concepts and architectural mechanisms that will be modeled. The analysis covers the MIPS pipeline structure, instruction execution mechanics, hazard detection, and resolution techniques that form the conceptual basis for the simulator implementation.

\section{MIPS Pipeline Architecture}

\subsection{Pipeline Structure and Stage Definition}
The MIPS pipeline employs a five-stage architecture designed to maximize instruction throughput by enabling concurrent processing of multiple instructions. As illustrated in Figure~\ref{fig:pipeline}, each stage performs specialized operations while maintaining data flow through pipeline registers.

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.8\textwidth]{fig/pipeline.png}
    \caption{General structure of the 5-stage MIPS pipeline~\cite{website}.}
    \label{fig:pipeline}
\end{figure}

The five stages operate as follows:
\begin{itemize}
    \item \textbf{Instruction Fetch (IF):} Retrieves instructions from memory using the program counter and increments PC
    \item \textbf{Instruction Decode (ID):} Decodes instruction fields, reads register values, and generates control signals
    \item \textbf{Execute (EX):} Performs arithmetic/logical operations and calculates memory addresses
    \item \textbf{Memory Access (MEM):} Handles data memory reads/writes for load/store instructions
    \item \textbf{Write Back (WB):} Writes results back to the register file
\end{itemize}

\subsection{Instruction Parallelism}
The pipeline achieves performance gains through instruction-level parallelism, where multiple instructions occupy different stages simultaneously. Figure~\ref{fig:instructions_pipeline} demonstrates this overlapping execution pattern, showing how the pipeline maintains a steady flow of instruction completion once initially filled.

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.8\textwidth]{fig/instructions_pipeline.png}
    \caption{Concurrent instruction execution in the MIPS pipeline~\cite{website}.}
    \label{fig:instructions_pipeline}
\end{figure}

\section{Instruction Set Architecture}

\subsection{Instruction Formats and Encoding}
The simulator implements all three primary instruction formats, each with a fixed 32-bit encoding scheme as shown in Figure~\ref{fig:instruction_format}. This consistent formatting enables efficient decoding and execution across all instruction types.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{fig/instruction_format.png}
    \caption{MIPS instruction encoding formats~\cite{lectures}.}
    \label{fig:instruction_format}
\end{figure}

\subsection{Instruction Categories and Examples}
The supported instruction set includes:

\textbf{R-type (Register Operations):} 
\begin{itemize}
    \item \texttt{ADD, SUB, AND, OR, SLT}
    \item \textcolor{blue}{Example: \texttt{add \$t0, \$t1, \$t2} - Register addition}
\end{itemize}

\textbf{I-type (Immediate/Memory Operations):}
\begin{itemize}
    \item \texttt{ADDI, LW, SW, BEQ, BNE}  
    \item \textcolor{green!70!black}{Example: \texttt{lw \$t0, 4(\$sp)} - Memory load operation}
\end{itemize}

\textbf{J-type (Jump Operations):}
\begin{itemize}
    \item \texttt{J, JAL}
    \item \textcolor{red!80!black}{Example: \texttt{j main} - Unconditional jump}
\end{itemize}

\subsection{Register Transfer Level (RTL) Description}

The simulator models instruction execution at the register transfer level, describing the data movements and operations between pipeline stages for each instruction type.

\subsubsection{R-type Instructions RTL Description}
For R-type instructions such as \texttt{add \$rd, \$rs, \$rt}:
\begin{align*}
\text{IF:} & \quad \text{IR} \leftarrow \text{Mem[PC]}, \quad \text{PC} \leftarrow \text{PC} + 4 \\
\text{ID:} & \quad \text{A} \leftarrow \text{Reg[\$rs]}, \quad \text{B} \leftarrow \text{Reg[\$rt]}, \quad \text{Decode opcode} \\
\text{EX:} & \quad \text{ALUOutput} \leftarrow \text{A} \oplus \text{B} \quad \text{where } \oplus \text{ is the ALU operation} \\
\text{MEM:} & \quad \text{No memory operation} \\
\text{WB:} & \quad \text{Reg[\$rd]} \leftarrow \text{ALUOutput}
\end{align*}

\subsubsection{I-type Load/Store RTL Description}
For load instructions such as \texttt{lw \$rt, offset(\$rs)}:
\begin{align*}
\text{IF:} & \quad \text{IR} \leftarrow \text{Mem[PC]}, \quad \text{PC} \leftarrow \text{PC} + 4 \\
\text{ID:} & \quad \text{A} \leftarrow \text{Reg[\$rs]}, \quad \text{Sign-extend immediate} \\
\text{EX:} & \quad \text{ALUOutput} \leftarrow \text{A} + \text{SignExt(imm)} \\
\text{MEM:} & \quad \text{LMD} \leftarrow \text{Mem[ALUOutput]} \\
\text{WB:} & \quad \text{Reg[\$rt]} \leftarrow \text{LMD}
\end{align*}

For store instructions such as \texttt{sw \$rt, offset(\$rs)}:
\begin{align*}
\text{IF:} & \quad \text{IR} \leftarrow \text{Mem[PC]}, \quad \text{PC} \leftarrow \text{PC} + 4 \\
\text{ID:} & \quad \text{A} \leftarrow \text{Reg[\$rs]}, \quad \text{B} \leftarrow \text{Reg[\$rt]}, \quad \text{Sign-extend immediate} \\
\text{EX:} & \quad \text{ALUOutput} \leftarrow \text{A} + \text{SignExt(imm)} \\
\text{MEM:} & \quad \text{Mem[ALUOutput]} \leftarrow \text{B} \\
\text{WB:} & \quad \text{No register writeback}
\end{align*}

\subsubsection{Branch Instructions RTL Description}
For branch instructions such as \texttt{beq \$rs, \$rt, label}:
\begin{align*}
\text{IF:} & \quad \text{IR} \leftarrow \text{Mem[PC]}, \quad \text{PC} \leftarrow \text{PC} + 4 \\
\text{ID:} & \quad \text{A} \leftarrow \text{Reg[\$rs]}, \quad \text{B} \leftarrow \text{Reg[\$rt]}, \quad \text{Target} \leftarrow \text{PC} + (\text{imm} \ll 2) \\
\text{EX:} & \quad \text{Condition} \leftarrow (\text{A} = \text{B}), \quad \text{If Condition then PC} \leftarrow \text{Target} \\
\text{MEM:} & \quad \text{Pipeline flush if branch taken} \\
\text{WB:} & \quad \text{No register writeback}
\end{align*}

\subsubsection{Jump Instructions RTL Description}
For jump instructions such as \texttt{j target}:
\begin{align*}
\text{IF:} & \quad \text{IR} \leftarrow \text{Mem[PC]}, \quad \text{PC} \leftarrow \text{PC} + 4 \\
\text{ID:} & \quad \text{Target} \leftarrow (\text{PC}_{31:28} \parallel (\text{address} \ll 2)) \\
\text{EX:} & \quad \text{PC} \leftarrow \text{Target} \\
\text{MEM:} & \quad \text{Pipeline flush} \\
\text{WB:} & \quad \text{No register writeback}
\end{align*}

\subsubsection{Pipeline Register Transfers}
The data flow between stages is maintained through pipeline registers:
\begin{align*}
\text{IF/ID:} & \quad \text{IR, PC+4} \\
\text{ID/EX:} & \quad \text{A, B, SignExt(imm), Control signals} \\
\text{EX/MEM:} & \quad \text{ALUOutput, B, Control signals} \\
\text{MEM/WB:} & \quad \text{LMD, ALUOutput, Control signals}
\end{align*}

This RTL description provides the formal specification for instruction execution that guides the simulator implementation, ensuring accurate modeling of the MIPS pipeline behavior.

\subsection{Supported Instruction Set}
\label{subsec:supported-instructions}
The simulator implements 18 core MIPS instructions covering arithmetic, memory, and control flow operations:

\begin{table}[H]
\centering
\begin{tabularx}{0.9\textwidth}{|l|l|X|}
\hline
\textbf{Type} & \textbf{Instruction} & \textbf{Description} \\
\hline
\rowcolor{gray!10}
\multicolumn{3}{|c|}{\textbf{R-type Instructions (Register Operations)}} \\
\hline
ADD & \texttt{add rd, rs, rt} & Integer addition \\
SUB & \texttt{sub rd, rs, rt} & Integer subtraction \\
AND & \texttt{and rd, rs, rt} & Bitwise AND \\
OR & \texttt{or rd, rs, rt} & Bitwise OR \\
SLT & \texttt{slt rd, rs, rt} & Set less than (signed) \\
\hline
\rowcolor{gray!10}
\multicolumn{3}{|c|}{\textbf{I-type Instructions (Immediate/Memory Operations)}} \\
\hline
ADDI & \texttt{addi rt, rs, imm} & Add immediate \\
LW & \texttt{lw rt, offset(rs)} & Load word from memory \\
SW & \texttt{sw rt, offset(rs)} & Store word to memory \\
BEQ & \texttt{beq rs, rt, label} & Branch if equal \\
BNE & \texttt{bne rs, rt, label} & Branch if not equal \\
ORI & \texttt{ori rt, rs, imm} & Bitwise OR immediate \\
ANDI & \texttt{andi rt, rs, imm} & Bitwise AND immediate \\
SLTI & \texttt{slti rt, rs, imm} & Set less than immediate \\
\hline
\rowcolor{gray!10}
\multicolumn{3}{|c|}{\textbf{J-type Instructions (Jump Operations)}} \\
\hline
J & \texttt{j target} & Unconditional jump \\
JAL & \texttt{jal target} & Jump and link \\
JR & \texttt{jr rs} & Jump to register \\
\hline
\end{tabularx}
\caption{Complete instruction set supported by the simulator.}
\label{tab:instruction_set}
\end{table}

\section{Pipeline Hazard Mechanisms}

\subsection{Hazard Classification and Detection}
Pipeline hazards represent situations when the next instruction cannot be executed in the following clock cycle. Three types of hazards can be distinguished:

\begin{itemize}
    \item \textbf{Structural Hazards:} Arise from resource conflicts; when two instructions attempt to use the same hardware component at the same time. An example is shown in Figure~\ref{fig:structural_hazard}, where the Load and Instruction 3 both need to access the memory in the same cycle.

    \begin{figure}[H]
        \centering
        \includegraphics[width=0.6\textwidth]{fig/structural_hazard.png}
        \caption{Simultaneous memory access of two instructions in different stages~\cite{lectures}.}
        \label{fig:structural_hazard}
    \end{figure}

    \item \textbf{Data Hazards:} Occur when instructions depend on results from previous instructions still in the pipeline. Figure~\ref{fig:data_hazard} presents a Read-After-Write (RAW) hazard where the \texttt{and} instruction needs \$2 in cycle 3 (during ID stage) or cycle 4 (during EX stage), but the value won't be available until cycle 5.
    
    \begin{figure}[H]
        \centering
        \includegraphics[width=0.6\textwidth]{fig/data_hazard.png}
        \caption{RAW Data Hazard~\cite{lectures}.}
        \label{fig:data_hazard}
    \end{figure}
    
    \item \textbf{Control Hazards:} Result from branch and jump instructions altering the program flow; attempt to make a decision about program control flow before the condition has been evaluated and the new program counter target address computed. An example is detailed below:

    \begin{verbatim}
    Cycle 1:  beq $t0, $t1, label    # Branch instruction
    Cycle 2:  add $t2, $t3, $t4      # Instruction after branch
    Cycle 3:  lw $t5, 0($t6)         # Second instruction after branch  
    Cycle 4:  label: add $t7, $t8, $t9  # Branch target
    \end{verbatim}
    
\end{itemize}

\subsection{Hazard Resolution Algorithms}
The simulator implements all three hazards presented above, as well as several resolution strategies to maintain pipeline efficiency:

\textbf{Pipeline Stall Algorithm:}
\begin{enumerate}
    \item Identify unresolvable data or structural hazards
    \item Insert pipeline bubbles by disabling register writes and PC updates
    \item Maintain pipeline state until hazard resolves
\end{enumerate}

\textbf{Forwarding Algorithm:}
\begin{enumerate}
    \item Detect data dependencies between instructions in EX/MEM/WB and ID stages
    \item Route results directly from producing stages to consuming stages
    \item Bypass register file access when newer data is available
\end{enumerate}

\textbf{Branch Prediction Strategy:}
\begin{enumerate}
    \item Assume branch not taken for simple prediction
    \item Flush pipeline if prediction proves incorrect
    \item Redirect instruction fetch to correct target address
    \item \textbf{Penalty:} 2 clock cycles lost when the branch is taken
\end{enumerate}

\section{Processor Components Architecture}

\subsection{Control Unit Design}
The control unit generates control signals across all pipeline stages based on decoded information from the instruction opcode and/or function field. Its operation follows this sequence:

\begin{enumerate}
    \item Analyze opcode and function fields during ID stage
    \item Generate stage-specific control signals (RegWrite, MemRead, MemWrite, ALUOp, etc.)
    \item Propagate control signals through pipeline registers
    \item Deactivate signals for instructions that don't use specific stages
\end{enumerate}

The data-path with control signals is depicted in Figure~\ref{fig:control_datapath}. Each of the described steps can be observed in blue.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{fig/control_unit.png}
    \caption{MIPS Pipeline Data-Path with control signals~\cite{website}.}
    \label{fig:control_datapath}
\end{figure}

\subsection{ALU Operations and Functionality}
The Arithmetic Logic Unit performs computations based on control signals and operand inputs. Key operations include:
\begin{itemize}
    \item Arithmetic: Addition, subtraction with overflow detection
    \item Logical: AND, OR, XOR, NOR operations
    \item Comparison: Set-less-than for signed and unsigned values
    \item Shift: Logical and arithmetic shift operations
\end{itemize}

\subsection{Memory Hierarchy and Register Organization}
The memory subsystem uses separate instruction and data memories following the Harvard architecture principle to avoid structural hazards. This separation allows simultaneous instruction fetch and data memory access in different pipeline stages.

\subsubsection{Register File Organization}
The MIPS architecture features 32 general-purpose 32-bit registers.

The register file organization supports pipeline operation through:
\begin{itemize}
    \item Dual read ports for simultaneous reading of two source operands during ID stage
    \item Single write port for register updates during WB stage
    \item The \texttt{\$zero} register is hardwired to value 0 for efficient constant generation
    \item Register bypass logic to handle RAW data hazards between pipeline stages
\end{itemize}

\subsubsection{Memory Organization}
The memory system features:
\begin{itemize}
    \item Byte-addressable 32-bit address space
    \item Word-aligned memory accesses (addresses divisible by 4)
    \item Selectable endianness
    \item Separate instruction and data memories to prevent structural hazards
    \item Memory-mapped I/O regions for input/output operations
\end{itemize}

\subsection{Simulation Methodology}

The simulator models the MIPS pipeline using a discrete, clock-driven approach. Each clock cycle represents a complete synchronization point where all pipeline stages update their state and data flow concurrently.

\subsubsection{Simulation Approach} 

\begin{itemize}
    \item \textbf{Clock-driven Execution:} The simulation advances one clock cycle at a time.
    \item \textbf{Pipeline Synchronization:} All stages (IF, ID, EX, MEM, WB) execute in parallel, maintaining consistent instruction flow.
    \item \textbf{Event Handling:} During each cycle, instructions progress through stages, hazards are managed, architectural state is updated, and the visualization reflects the new system state.
\end{itemize}

\subsubsection{Clock Cycle Execution Sequence}

Each clock cycle involves the following steps:

\begin{enumerate}
    \item Propagate instructions through pipeline stages (IF → ID → EX → MEM → WB)
    \item Detect and resolve hazards using forwarding or stalling
    \item Handle control flow changes and flush mispredicted instructions
    \item Update registers and memory with computed results
    \item Refresh the visualization and increment the simulation clock
\end{enumerate}


\chapter{Design}\label{ch:design}

This chapter presents the design and architectural structure of the MIPS pipeline simulator. Building on the theoretical concepts described in Chapter~\ref{ch:analysis}, this section outlines how those ideas are implemented in software.

\section{System Architecture Overview}

The simulator follows a modular, layered architecture composed of three main layers:

\begin{itemize}
    \item \textbf{Simulation Engine Layer} – Implements the core logic of instruction execution and hazard management.
    \item \textbf{Data Model Layer} – Represents the architectural state of the processor, including registers, memory, and pipeline registers.
    \item \textbf{Presentation Layer} – Provides visualization and interaction for the user through graphical components.
\end{itemize}

The layered approach promotes separation of concerns, making the design easy to maintain and extend in the future.

\section{User Interactions with the Simulator}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.3\textwidth]{fig/use_case_diagram.png}
    \caption{Use case diagram showing user interactions with the simulator.}
    \label{fig:use_case}
\end{figure}

As illustrated in Figure~\ref{fig:use_case}, users can load a MIPS program, execute it step-by-step or continuously, inspect the pipeline state, and enable or disable hazard resolution mechanisms. The main interactions include program loading, execution control, state inspection, and simulation reset.

\section{Simulator Components}

\begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{fig/class_diagram.png}
    \caption{Class diagram showing main system components and their relationships.}
    \label{fig:class_diagram}
\end{figure}

Figure~\ref{fig:class_diagram} illustrates the system's class structure. The simulator is centered around the \textbf{PipelineController}, which manages clock cycles, pipeline stage coordination, and hazard handling. Each pipeline stage—\textbf{FetchStage}, \textbf{DecodeStage}, \textbf{ExecuteStage}, \textbf{MemoryStage}, and \textbf{WriteBackStage}—is represented by a dedicated class responsible for its specific functionality.

\subsection{Core Components}

\textbf{PipelineController}

Coordinates overall execution, synchronizing pipeline stages each cycle. It interfaces with the hazard detection and forwarding units to ensure correct instruction flow.

\vspace{1ex} 

\textbf{HazardDetectionUnit}, \textbf{ForwardingUnit}, and \textbf{StallUnit}

These units collectively handle instruction dependencies and pipeline control. The \texttt{HazardDetectionUnit} identifies data, control, and structural hazards during each clock cycle. When a hazard cannot be resolved through data forwarding, the \texttt{StallUnit} introduces pipeline stalls to preserve correct execution order. The \texttt{ForwardingUnit} handles read-after-write (RAW) hazards by routing results directly between stages whenever possible.

\vspace{1ex}

\textbf{Pipeline Registers}

Classes such as \textbf{IF\_ID\_Register}, \textbf{ID\_EX\_Register}, \textbf{EX\_MEM\_Register}, and \textbf{MEM\_WB\_Register} hold intermediate data between stages, encapsulating control signals and operand values for the next clock cycle.

\vspace{2ex}

\subsection{Architectural State Components}

\textbf{\textbf{RegisterFile}}

Stores the 32 general-purpose registers. Provides simultaneous read ports and one write port for concurrent access during pipeline execution.

\vspace{1ex}

\textbf{\textbf{Memory Subsystem}}

Implemented as \textbf{InstructionMemory} and \textbf{DataMemory} classes, maintains separation between instruction fetch and data access paths.

\vspace{1ex}

\textbf{ProgramCounter}

Tracks the address of the instruction currently being fetched. Updated each cycle or redirected in case of branch instructions.

\vspace{1ex}

\textbf{ControlUnit}

Generates the control signals required by each instruction type, influencing multiplexers, ALU operations, and memory control lines.

\subsection{Pipeline Stages}

Each stage encapsulates its corresponding MIPS pipeline function:

\begin{itemize}
    \item \textbf{FetchStage}: Retrieves the next instruction from \textbf{InstructionMemory}.
    \item \textbf{DecodeStage}: Decodes instruction fields and reads operand values from the \textbf{RegisterFile}.
    \item \textbf{ExecuteStage}: Performs arithmetic or logical operations through the ALU.
    \item \textbf{MemoryStage}: Accesses or updates data memory for load and store instructions.
    \item \textbf{WriteBackStage}: Writes computed results back into the register file.
\end{itemize}

\section{Data Flow and Execution Sequence}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.3\textwidth]{fig/data_flow.png}
    \caption{Data flow diagram illustrating information exchange between components.}
    \label{fig:data_flow}
\end{figure}

As depicted in Figure~\ref{fig:data_flow}, the simulation proceeds in a sequence of discrete clock cycles managed by the \texttt{PipelineController}. Each cycle involves:

\begin{enumerate}
    \item Fetching the next instruction.
    \item Decoding and preparing operands.
    \item Executing ALU or branch operations.
    \item Accessing memory (if required).
    \item Writing results to registers.
\end{enumerate}

Hazard detection and forwarding operate concurrently during each cycle to maintain correctness.

\section{User Interface Components}

The visualization layer presents the internal state of the simulator in real time. It includes:

\begin{itemize}
    \item \textbf{PipelineVisualizer}: Displays the content and status of each pipeline stage.
    \item \textbf{RegisterDisplay}: Shows current register values and highlights recent changes.
    \item \textbf{ControlPanel}: Provides execution controls for stepping, running, pausing, and resetting the simulation.
\end{itemize}

These components are updated after every clock cycle, ensuring synchronized feedback between the simulation engine and the user interface.

\section{Component Interaction Summary}

During each clock cycle, the following sequence occurs:
\begin{itemize}
    \item The \textbf{PipelineController} triggers all stage modules.
    \item Pipeline registers propagate intermediate results.
    \item The \textbf{HazardDetectionUnit} and \textbf{ForwardingUnit} adjust data paths as needed.
    \item Architectural state components (\textbf{RegisterFile}, \textbf{Memory}, \textbf{ProgramCounter}) are updated.
    \item Visualization components refresh to display the new state.
\end{itemize}


\chapter{Implementation}\label{ch:implementation}

This chapter presents the implementation of the simulator, focusing on the Java backend and the web API for frontend communication. The implementation follows the architectural design from Chapter~\ref{ch:design} to build a functioning simulation engine with an intuitive user interface.

\section{Backend Implementation}

\subsection{Overall Architecture}

The backend implementation follows a modular, object-oriented architecture that closely mirrors the MIPS pipeline structure. The system is organized into several key packages:

\begin{itemize}
    \item \textbf{model.instruction:} Contains classes representing MIPS instructions (R-type, I-type, J-type) and their decoding logic.
    \item \textbf{model.cpu:} Implements CPU state components, including the register file, program counter, and memory subsystems.
    \item \textbf{model.control:} Houses the control unit, hazard detection unit, forwarding unit, and stall unit.
    \item \textbf{model.pipeline.stages:} Contains the five pipeline stage implementations (Fetch, Decode, Execute, Memory, WriteBack).
    \item \textbf{model.pipeline.registers:} Implements pipeline registers that buffer data between stages.
    \item \textbf{simulator:} Provides the main simulation engine, clock, and API server for frontend communication.
\end{itemize}

\subsection{Instruction Implementation}

Each instruction is represented as an object-oriented model, following the structure and behavior of its corresponding instruction format (R, I, or J-type). All instruction types extend a common abstract base class, \textbf{Instruction}, which provides the binary representation and the opcode, while subclasses handle specific field decoding.

\begin{lstlisting}[style=javaStyle]
public abstract class Instruction {
    private final int opcode;
    private final int binary;

    protected Instruction(int opcode, int binary) {
        this.opcode = opcode;
        this.binary = binary;
    }

    public int getOpcode() { return opcode; }
    public int getBinary() { return binary; }

    public abstract void decodeFields();
}
\end{lstlisting}

\subsection*{R-Type Instruction}

The \textbf{RTypeInstruction} class extracts its fields (two source registers, destination register, shift amount and function code) using bit shifting and masking:

\begin{lstlisting}[style=javaStyle]
@Override
public void decodeFields() {
    int binary = getBinary();
    rs = (binary >> 21) & 0x1F;
    rt = (binary >> 16) & 0x1F;
    rd = (binary >> 11) & 0x1F;
    shamt = (binary >> 6) & 0x1F;
    func = binary & 0x3F;
}
\end{lstlisting}

\subsection*{I-Type Instruction}

The \textbf{ITypeInstruction} class decodes the 16-bit immediate field, ensuring sign-extension where necessary:

\begin{lstlisting}[style=javaStyle]
@Override
public void decodeFields() {
    int binary = getBinary();
    rs = (binary >> 21) & 0x1F;
    rt = (binary >> 16) & 0x1F;
    immediate = binary & 0xFFFF;
    if ((immediate & 0x8000) != 0) immediate |= 0xFFFF0000; // sign-extend
}
\end{lstlisting}

\subsection*{J-Type Instruction}

The \texttt{JTypeInstruction} class simply extracts the target address as:

\begin{lstlisting}[style=javaStyle]
@Override
public void decodeFields() {
    address = getBinary() & 0x03FFFFFF;
}
\end{lstlisting}

\subsection{Memory Subsystem}

\subsection*{Instruction Memory}
The \textbf{InstructionMemory} class stores and provides access to instruction objects in a fixed-size, word-aligned memory array (4 KB = 1024 words). The class provides methods for accessing the contents:
\begin{itemize}
    \item Call \textbf{setInstruction(int, Instruction)} to store an instruction at a given address.
    \item Call \textbf{fetch(int)} to retrieve the instruction from a given address.
\end{itemize}
If an address is outside the valid range (0--4092), \textbf{fetch()} returns \texttt{null} and \textbf{setInstruction()} does nothing.

\subsection*{Data Memory}
The \textbf{DataMemory} class provides word-aligned load and store operations for reading and writing 32-bit values through \textbf{loadWord(int)} and \textbf{storeWord(int, int)} methods. Out-of-range addresses are safely ignored:
\begin{itemize}
    \item \texttt{loadWord(int)} returns 0 for invalid addresses.
    \item \texttt{storeWord(int, int)} does nothing for invalid addresses.
\end{itemize}

\subsection{CPU State Components}

\subsection*{Register File}

The \textbf{RegisterFile} class models the 32 general-purpose registers in the MIPS CPU through an Integer array. Register 0 (\$zero) is immutable and always holds the value 0. Other registers can be read and written using \textbf{get()} and \textbf{set()} methods.

\subsection*{Program Counter}

The \textbf{ProgramCounter} class models the program counter (PC) of the processor, tracking the address of the current instruction being executed, and providing additional methods to update it.
\begin{itemize}
    \item The program counter (\textbf{pc}) is stored as a 32-bit integer.
    \item The PC can be read using the \textbf{get()} method.
    \item The PC can be set directly using the \textbf{set(int value)} method.
    \item The PC can be advanced to the next instruction using \textbf{increment()}, which increases it by 4 (word-aligned).
    \item An arbitrary offset can be added to the PC using \textbf{addOffset(int offset)}.
\end{itemize}

\subsection*{CPU State}

The \textbf{CPUState} class acts as a central container for the CPU's state, allowing pipeline stages or simulator code to access and modify registers, memory, and the PC. The instruction memory is provided via the constructor, while the other components are initialized internally.
\begin{lstlisting}[style=javaStyle]
public class CPUState {
    public RegisterFile registerFile = new RegisterFile();
    public InstructionMemory instructionMemory;
    public DataMemory dataMemory = new DataMemory();
    public ProgramCounter pc = new ProgramCounter();
    
    public CPUState(InstructionMemory instrMem) {
        this.instructionMemory = instrMem;
    }
}
\end{lstlisting}

\subsection{Control Handling}

\subsection*{Control Unit}

The \textbf{ControlUnit} class implements the control logic designed in Section~\ref{ch:design}. It generates control signals based on the instruction opcode to coordinate data flow and ALU operations for the full instruction set.

\paragraph{Control Signals}
\begin{itemize}
    \item \texttt{regWrite} --- writes to the register file
    \item \texttt{memToReg} --- selects memory data vs ALU result
    \item \texttt{branch} --- branch instruction
    \item \texttt{memRead} --- load instruction
    \item \texttt{memWrite} --- store instruction
    \item \texttt{regDst} --- selects destination register (rd vs rt)
    \item \texttt{aluSrc} --- selects ALU operand (immediate vs register)
    \item \texttt{aluOp} --- ALU operation code
    \item \texttt{jump} --- jump instruction
\end{itemize}

\subsection*{Hazard Detection Unit}

The \textbf{HazardDetectionUnit} implements the hazard detection mechanism described in the design. It monitors the \textbf{PipelineRegisters} to detect data, control, and structural hazards through dedicated methods: \textbf{checkDataHazards(regs)}, \textbf{checkControlHazards(regs)}, \textbf{checkStructuralHazards(regs)}. 

It reports detected hazards through a \textbf{HazardReport} object, which lists all detected conditions and indicates whether stalling or flushing is required. Supporting units such as \textbf{ForwardingUnit} and \textbf{StallUnit} use this information to apply the appropriate solution.

\subsection*{Forwarding Unit}

The \textbf{ForwardingUnit} resolves data hazards by forwarding results from later pipeline stages to the ALU inputs in the \textbf{EX} stage. It compares the source registers (\texttt{Rs}, \texttt{Rt}) of the instruction in the \textbf{ID/EX} pipeline register with the destination registers of the instructions in the \textbf{EX/MEM} and \textbf{MEM/WB} pipeline registers. 

If a match is detected and the corresponding instruction writes to a register (\texttt{RegWrite = 1}) other than \texttt{\$zero}, the unit sets the forwarding control signals as follows:

\begin{itemize}
    \item \texttt{10} --- Forward from \textbf{EX/MEM} stage
    \item \texttt{01} --- Forward from \textbf{MEM/WB} stage
    \item \texttt{00} --- No forwarding
\end{itemize}

The forwarding signals are encapsulated in the \textbf{ForwardingResult} structure:
\begin{lstlisting}[style=javaStyle]
public static class ForwardingResult {
    public final int forwardA;
    public final int forwardB;

    public ForwardingResult(int forwardA, int forwardB) {
        this.forwardA = forwardA;
        this.forwardB = forwardB;
    }
}
\end{lstlisting}

\subsection*{Stall Unit}

The \textbf{StallUnit} receives hazard detection signals from the \textbf{HazardDetectionUnit} and issues stall control signals when a \textit{load-use hazard} is detected.

If a stall is required, the unit:
\begin{itemize}
    \item Prevents updates to the \textbf{PC} and \textbf{IF/ID} pipeline register
    \item Clears the control signals in the \textbf{ID/EX} pipeline register to insert a \texttt{bubble} (a no-operation)
\end{itemize}

The control signals are encapsulated in the \textbf{StallControl} structure:
\begin{lstlisting}[style=javaStyle]
public static class StallControl {
    public final boolean stall;     // true if stalling
    public final boolean pcWrite;   // enable PC update
    public final boolean ifidWrite; // enable IF/ID update
    public final boolean idExClear; // flush ID/EX (insert bubble)
}
\end{lstlisting}

\subsection{Pipeline Representation}

\subsection*{Pipeline Stages}

The MIPS CPU pipeline is implemented through five concrete classes, each derived from the \textbf{PipelineStage} interface:
\begin{lstlisting}[style=javaStyle]
public interface PipelineStage {
    void process(CPUState state, PipelineRegisters regs);
}
\end{lstlisting}

Each stage implements the functionality outlined in Section~\ref{ch:design}:

\begin{itemize}
    \item \textbf{Fetch (IF)} --- Retrieves the next instruction from instruction memory using the current \textbf{PC}, computes \texttt{PC+4}, and stores both the instruction and the incremented PC value into the \textbf{IF/ID} pipeline register.
    
    \item \textbf{Decode (ID)} --- Decodes the fetched instruction, reads operand values from the register file, and generates control signals via the \textbf{ControlUnit}. For jump or branch instructions, it computes the potential target address.
    
    \item \textbf{Execute (EX)} --- Performs arithmetic and logical operations using the ALU, computes branch target addresses, determines the destination register, evaluates branch conditions, and applies data forwarding to resolve read-after-write (RAW) hazards.
    
    \item \textbf{Memory Access (MEM)} --- Performs data memory operations (\texttt{lw}, \texttt{sw}) and finalizes branch resolution. If a branch is taken, it updates the PC and triggers pipeline flushes.
    
    \item \textbf{Write Back (WB)} --- Writes the result of an ALU operation or a value loaded from memory back into the register file.
\end{itemize}

\subsection*{Pipeline Registers}

The pipeline register classes implement the buffering mechanism between pipeline stages:

\begin{itemize}
    \item \textbf{PipelineRegisters}: A container class that holds all stage-specific registers.
    \begin{lstlisting}[style=javaStyle]
    public class PipelineRegisters {
        public IF_ID_Register IF_ID = new IF_ID_Register();
        public ID_EX_Register ID_EX = new ID_EX_Register();
        public EX_MEM_Register EX_MEM = new EX_MEM_Register();
        public MEM_WB_Register MEM_WB = new MEM_WB_Register();
    }
    \end{lstlisting}

    \item \textbf{IF\_ID\_Register}: Stores the fetched instruction and PC for decode stage.

    \text{Fields: } \texttt{instruction, pc}

    \item \textbf{ID\_EX\_Register}: Holds data read from register file, sign-extended immediate values, and control signals.

    \text{Fields: } \texttt{readData1, readData2, signExtendedImm, pcPlus4, rs, rt, rd, regWrite, memToReg, branch, memRead, memWrite, regDst, aluSrc, aluOp, instruction}

    \item \textbf{EX\_MEM\_Register}: Contains ALU results, memory write data, branch information, and control signals.

    \text{Fields: } \texttt{aluResult, zeroFlag, writeData, branchTarget, branchTaken, destReg, regWrite, memToReg, branch, memRead, memWrite, instruction}

    \item \textbf{MEM\_WB\_Register}: Holds data for write-back to register file.

    \text{Fields: } \texttt{aluResult, memData, destReg, regWrite, memToReg, instruction}
\end{itemize}

The method \textbf{getWriteData()} selects between ALU result and memory data based on the \texttt{memToReg} signal.

\subsection{The Simulation Engine}

\subsection*{Pipeline Controller}

The \textbf{PipelineController} implements the central coordination logic for the 5-stage MIPS pipeline, integrating CPU state and pipeline registers to simulate concurrent instruction execution.

\begin{lstlisting}[style=javaStyle]
public class PipelineController {
    private final CPUState cpuState;
    private final PipelineRegisters pipelineRegisters = new PipelineRegisters();
    private final StallUnit stallUnit = new StallUnit();
    
    private final FetchStage fetch = new FetchStage();
    private final DecodeStage decode = new DecodeStage();
    private final ExecuteStage execute = new ExecuteStage();
    private final MemoryStage memory = new MemoryStage();
    private final WriteBackStage writeBack = new WriteBackStage();
    
    public void runCycle() {
        // processes each stage
    }
}
\end{lstlisting}

\paragraph{Pipeline Operation:}
The controller processes stages in reverse order (WB $\rightarrow$ MEM $\rightarrow$ EX $\rightarrow$ ID $\rightarrow$ IF) to ensure write-back occurs before subsequent reads. Each cycle, it checks for hazards, applies stalls if needed, and updates pipeline registers.

\paragraph{Hazard Handling:}
\begin{itemize}
    \item \textbf{Load-Use Hazards:} Detected by the \textbf{StallUnit}, which stalls the pipeline by freezing the \textbf{PC} and \textbf{IF/ID} register updates and clearing control signals in \textbf{ID/EX} to insert a bubble.
    \item \textbf{Control Hazards:} Branch instructions follow a \textit{predict-not-taken} policy. If a branch is taken, the controller flushes \textbf{IF/ID} and \textbf{ID/EX} registers, introducing a two-cycle penalty.
\end{itemize}

\subsection*{Clock}

The \textbf{Clock} class simulates the global clock of the MIPS pipeline, advancing the pipeline cycle by cycle through the \textbf{PipelineController}.

\begin{lstlisting}[style=javaStyle]
public class Clock {
    private int cycle = 0;
    private final PipelineController pipelineController;

    public Clock(PipelineController pipelineController) {
        this.pipelineController = pipelineController;
    }

    public void tick() {
        pipelineController.cycle();
        cycle++;
    }

    public int getCycle() { return cycle; }

    public void run(int n) {
        for (int i = 0; i < n; i++) tick();
    }
}
\end{lstlisting}

The \textbf{tick()} method advances the simulation by one clock cycle, while \textbf{run(int n)} executes multiple cycles in sequence, supporting both step-by-step and continuous execution modes.

\subsection{Program Loading and Instruction Parsing}
\subsection*{Program Loader}

The \textbf{ProgramLoader} class handles initialization and loading of MIPS programs into instruction memory, supporting multiple input formats:

\begin{itemize}
    \item \textbf{Integer Array:} Direct 32-bit integer values representing binary instruction words
    \item \textbf{Hexadecimal Strings:} Text-based hex representation (with or without \texttt{0x} prefix)
\end{itemize}

Key features include:
\begin{itemize}
    \item \textbf{Instruction Parsing:} examines the 6 most significant bits (opcode) to determine instruction format.
    \begin{lstlisting}[style=javaStyle]
    public static Instruction parseInstruction(int binaryWord) {
        int opcode = (binaryWord >> 26) & 0x3F;
        
        if (opcode == 0x00) {
            return new RTypeInstruction(opcode, binaryWord);
        } else if (opcode == 0x02 || opcode == 0x03) {
            return new JTypeInstruction(opcode, binaryWord);
        } else {
            return new ITypeInstruction(opcode, binaryWord);
        }
    }
    \end{lstlisting}
    \item \textbf{Address Validation:} Ensures instruction addresses are word-aligned and within memory bounds
    \item \textbf{Bounds Checking:} Prevents loading instructions beyond memory capacity
    \item \textbf{Warning System:} Collects warnings for out-of-bounds instructions without failing the load operation
    \item \textbf{State Management:} Provides methods to reset CPU state
\end{itemize}

The \textbf{loadFromHexStrings()} method processes hex input:
\begin{lstlisting}[style=javaStyle]
public static ProgramLoadResult loadFromHexStrings(
    CPUState state, String[] hexLines, int startAddress) {
    validateStartAddress(startAddress);
    
    int[] words = new int[hexLines.length];
    for (int i = 0; i < hexLines.length; i++) {
        words[i] = parseHexToInt(hexLines[i]);
    }
    
    return loadFromIntArray(state, words, startAddress);
}
\end{lstlisting}

The \textbf{ProgramLoadResult} class encapsulates load operation outcomes:
\begin{itemize}
    \item Number of successfully loaded instructions
    \item Start and end addresses of the loaded program
    \item List of warnings generated during loading
\end{itemize}

\subsection{API Server and Frontend Integration}

To enable web-based interaction with the simulator, a lightweight HTTP API server was implemented using Java's built-in \textbf{HttpServer}. This API provides a RESTful interface for controlling the simulation and querying CPU state.

\subsection*{API Architecture}

The \textbf{ApiServer} class manages HTTP request handling and coordinates between the simulation engine and external clients. It maintains references to the \textbf{HttpServer} object and \textbf{ServerContext}.

\begin{lstlisting}[style=javaStyle]
public class ApiServer {
    private final HttpServer server;
    private final ServerContext context;
    
    public ApiServer(int port) throws IOException {
		CPUState cpuState = new CPUState(new InstructionMemory());
		PipelineController controller = new PipelineController(cpuState);
		Clock clock = new Clock(controller);
		this.context = new ServerContext(cpuState, controller, clock);

		this.server = HttpServer.create(new InetSocketAddress(port), 0);

		server.createContext("/api/load", new LoadHandler(context));
		server.createContext("/api/step", new StepHandler(context));
		server.createContext("/api/state", new StateHandler(context));
		server.createContext("/api/reset", new ResetHandler(context));
		server.createContext("/api/health", new HealthHandler());

		server.setExecutor(null);
	}
}
\end{lstlisting}

\subsection*{Server Context}
The \textbf{ServerContext} class wraps the \textbf{CPUState}, \textbf{PipelineController}, and \textbf{Clock} instances to maintain a single source of information during the simulation. It can be said that the core of the simulator is kept here.

\subsection*{API Endpoints}

The API exposes five main endpoints, each taken care of by a handler class— \textbf{LoadHandler}, \textbf{StepHandler}, \textbf{StateHandler}, \textbf{ResetHandler}, \textbf{HealthHandler}:

\begin{enumerate}
    \item \textbf{POST /api/load} --- Loads a program into instruction memory
    \begin{itemize}
        \item Query parameter: \texttt{start} (default: 0) --- Starting address for program loading
        \item Request body: Newline-separated hexadecimal instruction strings
        \item Response: JSON containing loaded count, start address, and end address
    \end{itemize}

    \item \textbf{POST /api/step} --- Advances simulation by specified number of cycles
    \begin{itemize}
        \item Query parameter: \texttt{cycles} (default: 1) --- Number of clock cycles to execute
        \item Response: JSON confirming number of cycles executed
    \end{itemize}

    \item \textbf{GET /api/state} --- Retrieves current CPU and pipeline state
    \begin{itemize}
        \item Response: JSON representation of registers, program counter, and pipeline registers
    \end{itemize}

    \item \textbf{POST /api/reset} --- Resets the simulator to initial state
    \begin{itemize}
        \item Query parameters:
        \begin{itemize}
            \item \texttt{clearRegs} --- Clear all registers (boolean)
            \item \texttt{clearMem} --- Clear data memory (boolean)
            \item \texttt{pc} --- Reset program counter to specified address (default: 0)
        \end{itemize}
        \item Response: JSON confirmation of reset operation
    \end{itemize}

    \item \textbf{GET /api/health} --- Health check endpoint for monitoring
    \begin{itemize}
        \item Response: Simple \texttt{"ok"} string
    \end{itemize}
\end{enumerate}

\subsection*{Cross-Origin Resource Sharing (CORS)}

The API server implements CORS headers to allow web-based frontends running on different origins to communicate with the simulator. All endpoints include the following headers:

\begin{itemize}
    \item \texttt{Access-Control-Allow-Origin: *}
    \item \texttt{Access-Control-Allow-Methods: GET, POST, OPTIONS}
    \item \texttt{Access-Control-Allow-Headers: Content-Type}
\end{itemize}

This enables the frontend application, hosted separately from the backend to make API requests without browser security restrictions. 

\subsection*{State Serialization}

The \textbf{StateSerializer} class converts the internal CPU and pipeline state into JSON format for transmission to the frontend. This serialization process:

\begin{itemize}
    \item Extracts program counter value
    \item Serializes all 32 registers into a JSON array
    \item Serializes pipeline register contents (IF/ID, ID/EX, EX/MEM, MEM/WB)
    \item Formats the data as a structured JSON object
\end{itemize}

\begin{lstlisting}[style=javaStyle]
public static String serialize(CPUState state, PipelineController controller) {
    StringBuilder sb = new StringBuilder();
    sb.append("{");
    sb.append("\"pc\":").append(state.pc.get()).append(',');
    sb.append("\"registers\":").append(serializeRegisters(state)).append(',');
    sb.append("\"pipeline\":").append(serializePipeline(controller));
    sb.append("}");
    return sb.toString();
}
\end{lstlisting}

The serialized state enables the frontend to:
\begin{itemize}
    \item Display current register values
    \item Visualize instructions in each pipeline stage
    \item Track program execution progress
    \item Highlight data dependencies and hazards
\end{itemize}

\subsection*{Error Handling}

The API implements robust error handling:
\begin{itemize}
    \item Invalid HTTP methods return \texttt{405 Method Not Allowed}
    \item Malformed program data returns \texttt{400 Bad Request} with error details
    \item Invalid addresses or parameters are validated before processing
    \item Exceptions are caught and returned as JSON error responses
\end{itemize}

This design ensures that the frontend receives meaningful error messages and can handle any conditions that may arise during simulation.

\printbibliography
\nocite{*}

\vspace{2cm}
\begin{center}
  Distributed systems (DS)\\
  \includegraphics[width=10cm]{fig/footer}
\end{center}

\end{document}